/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://10.55.15.98";
    }

    /**
     * @param username (optional) 
     * @return OK
     */
    getAllUsers(username: string | null | undefined, session_token: string): Observable<ApiResultOfIListOfUser> {
        let url_ = this.baseUrl + "/api/auth/GetAllUsers?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIListOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIListOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ApiResultOfIListOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIListOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIListOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    login(payload: UserLoginPayload, session_token: string): Observable<ApiResultOfUser> {
        let url_ = this.baseUrl + "/api/auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ApiResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    validateToken(session_token: string): Observable<ApiResultOfUser> {
        let url_ = this.baseUrl + "/api/auth/ValidateToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateToken(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processValidateToken(response: HttpResponseBase): Observable<ApiResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    logout(session_token: string): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }

    /**
     * @return OK
     */
    changePassword(payload: ChangePINPayload, session_token: string): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }

    /**
     * @return OK
     */
    sendOTP(username: string, session_token: string): Observable<ApiResultOfInt32> {
        let url_ = this.baseUrl + "/api/auth/SendOTP?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOTP(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processSendOTP(response: HttpResponseBase): Observable<ApiResultOfInt32> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfInt32.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfInt32>(<any>null);
    }

    /**
     * @return OK
     */
    verifyOTP(username: string, phoneno: string, otp: number, session_token: string): Observable<ApiResultOfMessageOut> {
        let url_ = this.baseUrl + "/api/auth/VerifyOTP?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (phoneno === undefined || phoneno === null)
            throw new Error("The parameter 'phoneno' must be defined and cannot be null.");
        else
            url_ += "phoneno=" + encodeURIComponent("" + phoneno) + "&";
        if (otp === undefined || otp === null)
            throw new Error("The parameter 'otp' must be defined and cannot be null.");
        else
            url_ += "otp=" + encodeURIComponent("" + otp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyOTP(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfMessageOut>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfMessageOut>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyOTP(response: HttpResponseBase): Observable<ApiResultOfMessageOut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfMessageOut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfMessageOut>(<any>null);
    }
}

@Injectable()
export class LotusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://10.55.15.98";
    }

    /**
     * @return OK
     */
    getAccountDetails(accountno: string, session_token: string): Observable<ApiResultOfGetAccountDetailsResponse> {
        let url_ = this.baseUrl + "/api/lotus/getAccountDetails?";
        if (accountno === undefined || accountno === null)
            throw new Error("The parameter 'accountno' must be defined and cannot be null.");
        else
            url_ += "accountno=" + encodeURIComponent("" + accountno) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountDetails(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetAccountDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetAccountDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountDetails(response: HttpResponseBase): Observable<ApiResultOfGetAccountDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetAccountDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetAccountDetailsResponse>(<any>null);
    }

    /**
     * @return OK
     */
    nameenquiry(payload: NameEnquiryPayload, session_token: string): Observable<ApiResultOfNameEnquiryResponse> {
        let url_ = this.baseUrl + "/api/lotus/nameenquiry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNameenquiry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNameenquiry(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNameEnquiryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNameEnquiryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processNameenquiry(response: HttpResponseBase): Observable<ApiResultOfNameEnquiryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNameEnquiryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNameEnquiryResponse>(<any>null);
    }

    /**
     * @param amt (optional) 
     * @return OK
     */
    singleGet(cr: string, dr: string, amt: number | null | undefined, session_token: string): Observable<ApiResultOfRoot> {
        let url_ = this.baseUrl + "/api/lotus/single?";
        if (cr === undefined || cr === null)
            throw new Error("The parameter 'cr' must be defined and cannot be null.");
        else
            url_ += "cr=" + encodeURIComponent("" + cr) + "&";
        if (dr === undefined || dr === null)
            throw new Error("The parameter 'dr' must be defined and cannot be null.");
        else
            url_ += "dr=" + encodeURIComponent("" + dr) + "&";
        if (amt !== undefined && amt !== null)
            url_ += "amt=" + encodeURIComponent("" + amt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingleGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRoot>><any>_observableThrow(response_);
        }));
    }

    protected processSingleGet(response: HttpResponseBase): Observable<ApiResultOfRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRoot>(<any>null);
    }

    /**
     * @return OK
     */
    singlePost(payload: SingleBody, session_token: string): Observable<ApiResultOfRoot> {
        let url_ = this.baseUrl + "/api/lotus/single";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSinglePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSinglePost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRoot>><any>_observableThrow(response_);
        }));
    }

    protected processSinglePost(response: HttpResponseBase): Observable<ApiResultOfRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRoot>(<any>null);
    }

    /**
     * @return OK
     */
    nipTransfer(payload: Nptransfer, session_token: string): Observable<ApiResultOfNpRoot> {
        let url_ = this.baseUrl + "/api/lotus/nipTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNipTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNipTransfer(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNpRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNpRoot>><any>_observableThrow(response_);
        }));
    }

    protected processNipTransfer(response: HttpResponseBase): Observable<ApiResultOfNpRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNpRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNpRoot>(<any>null);
    }

    /**
     * @return OK
     */
    tellerCashDep(payload: CtRoot, session_token: string): Observable<ApiResultOfCtRRoot> {
        let url_ = this.baseUrl + "/api/lotus/tellerCashDep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTellerCashDep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTellerCashDep(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfCtRRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfCtRRoot>><any>_observableThrow(response_);
        }));
    }

    protected processTellerCashDep(response: HttpResponseBase): Observable<ApiResultOfCtRRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfCtRRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfCtRRoot>(<any>null);
    }

    /**
     * @return OK
     */
    singleGenericCall(payload: SingleBody, session_token: string): Observable<ApiResultOfRoot> {
        let url_ = this.baseUrl + "/api/lotus/SingleGenericCall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingleGenericCall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingleGenericCall(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRoot>><any>_observableThrow(response_);
        }));
    }

    protected processSingleGenericCall(response: HttpResponseBase): Observable<ApiResultOfRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRoot>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://10.55.15.98";
    }

    /**
     * @return OK
     */
    valuesGet(session_token: string): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesGet(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processValuesGet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return No Content
     */
    valuesPost(value: string, session_token: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValuesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return OK
     */
    valuesGetid(id: number, session_token: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesGetid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesGetid(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processValuesGetid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return No Content
     */
    valuesPut(id: number, value: string, session_token: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValuesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return No Content
     */
    valuesDelete(id: number, session_token: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValuesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class ApiResultOfIListOfUser implements IApiResultOfIListOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User[] | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfIListOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Result"])) {
                this.result = [] as any;
                for (let item of _data["Result"])
                    this.result.push(User.fromJS(item));
            }
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfIListOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIListOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        if (Array.isArray(this.result)) {
            data["Result"] = [];
            for (let item of this.result)
                data["Result"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfIListOfUser {
        const json = this.toJSON();
        let result = new ApiResultOfIListOfUser();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfIListOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User[] | undefined;
    totalCount: number | undefined;
}

export class User implements IUser {
    id: number | undefined;
    username: string | undefined;
    pINHash: string | undefined;
    pIN: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    phoneNo: string | undefined;
    oTP: number | undefined;
    oTPExpiryDate: Date | undefined;
    sessionToken: string | undefined;
    sessionTokenExpiry: Date | undefined;
    userAccounts: UserAccount[] | undefined;
    userRoles: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.username = _data["Username"];
            this.pINHash = _data["PINHash"];
            this.pIN = _data["PIN"];
            this.fullName = _data["FullName"];
            this.emailAddress = _data["EmailAddress"];
            this.phoneNo = _data["PhoneNo"];
            this.oTP = _data["OTP"];
            this.oTPExpiryDate = _data["OTPExpiryDate"] ? new Date(_data["OTPExpiryDate"].toString()) : <any>undefined;
            this.sessionToken = _data["SessionToken"];
            this.sessionTokenExpiry = _data["SessionTokenExpiry"] ? new Date(_data["SessionTokenExpiry"].toString()) : <any>undefined;
            if (Array.isArray(_data["UserAccounts"])) {
                this.userAccounts = [] as any;
                for (let item of _data["UserAccounts"])
                    this.userAccounts.push(UserAccount.fromJS(item));
            }
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Username"] = this.username;
        data["PINHash"] = this.pINHash;
        data["PIN"] = this.pIN;
        data["FullName"] = this.fullName;
        data["EmailAddress"] = this.emailAddress;
        data["PhoneNo"] = this.phoneNo;
        data["OTP"] = this.oTP;
        data["OTPExpiryDate"] = this.oTPExpiryDate ? this.oTPExpiryDate.toISOString() : <any>undefined;
        data["SessionToken"] = this.sessionToken;
        data["SessionTokenExpiry"] = this.sessionTokenExpiry ? this.sessionTokenExpiry.toISOString() : <any>undefined;
        if (Array.isArray(this.userAccounts)) {
            data["UserAccounts"] = [];
            for (let item of this.userAccounts)
                data["UserAccounts"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number | undefined;
    username: string | undefined;
    pINHash: string | undefined;
    pIN: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    phoneNo: string | undefined;
    oTP: number | undefined;
    oTPExpiryDate: Date | undefined;
    sessionToken: string | undefined;
    sessionTokenExpiry: Date | undefined;
    userAccounts: UserAccount[] | undefined;
    userRoles: UserRole[] | undefined;
}

export class UserAccount implements IUserAccount {
    id: number | undefined;
    userId: number | undefined;
    accountNo: string | undefined;
    accountType: string | undefined;
    accountName: string | undefined;
    isDefault: boolean | undefined;
    isActive: boolean | undefined;

    constructor(data?: IUserAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.accountNo = _data["AccountNo"];
            this.accountType = _data["AccountType"];
            this.accountName = _data["AccountName"];
            this.isDefault = _data["IsDefault"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): UserAccount {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["AccountNo"] = this.accountNo;
        data["AccountType"] = this.accountType;
        data["AccountName"] = this.accountName;
        data["IsDefault"] = this.isDefault;
        data["IsActive"] = this.isActive;
        return data; 
    }

    clone(): UserAccount {
        const json = this.toJSON();
        let result = new UserAccount();
        result.init(json);
        return result;
    }
}

export interface IUserAccount {
    id: number | undefined;
    userId: number | undefined;
    accountNo: string | undefined;
    accountType: string | undefined;
    accountName: string | undefined;
    isDefault: boolean | undefined;
    isActive: boolean | undefined;
}

export class UserRole implements IUserRole {
    id: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    role: Role | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    role: Role | undefined;
}

export class Role implements IRole {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        return data; 
    }

    clone(): Role {
        const json = this.toJSON();
        let result = new Role();
        result.init(json);
        return result;
    }
}

export interface IRole {
    id: number | undefined;
    name: string | undefined;
}

export class UserLoginPayload implements IUserLoginPayload {
    username: string | undefined;
    pIN: string | undefined;
    oTP: number | undefined;
    authMode: string | undefined;

    constructor(data?: IUserLoginPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["Username"];
            this.pIN = _data["PIN"];
            this.oTP = _data["OTP"];
            this.authMode = _data["AuthMode"];
        }
    }

    static fromJS(data: any): UserLoginPayload {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Username"] = this.username;
        data["PIN"] = this.pIN;
        data["OTP"] = this.oTP;
        data["AuthMode"] = this.authMode;
        return data; 
    }

    clone(): UserLoginPayload {
        const json = this.toJSON();
        let result = new UserLoginPayload();
        result.init(json);
        return result;
    }
}

export interface IUserLoginPayload {
    username: string | undefined;
    pIN: string | undefined;
    oTP: number | undefined;
    authMode: string | undefined;
}

export class ApiResultOfUser implements IApiResultOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? User.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfUser {
        const json = this.toJSON();
        let result = new ApiResultOfUser();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User | undefined;
    totalCount: number | undefined;
}

export class ApiResultOfBoolean implements IApiResultOfBoolean {
    hasError: boolean | undefined;
    message: string | undefined;
    result: boolean | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfBoolean {
        const json = this.toJSON();
        let result = new ApiResultOfBoolean();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfBoolean {
    hasError: boolean | undefined;
    message: string | undefined;
    result: boolean | undefined;
    totalCount: number | undefined;
}

export class ChangePINPayload implements IChangePINPayload {
    currentPIN: string | undefined;
    newPIN: string | undefined;

    constructor(data?: IChangePINPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPIN = _data["CurrentPIN"];
            this.newPIN = _data["NewPIN"];
        }
    }

    static fromJS(data: any): ChangePINPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePINPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CurrentPIN"] = this.currentPIN;
        data["NewPIN"] = this.newPIN;
        return data; 
    }

    clone(): ChangePINPayload {
        const json = this.toJSON();
        let result = new ChangePINPayload();
        result.init(json);
        return result;
    }
}

export interface IChangePINPayload {
    currentPIN: string | undefined;
    newPIN: string | undefined;
}

export class ApiResultOfInt32 implements IApiResultOfInt32 {
    hasError: boolean | undefined;
    message: string | undefined;
    result: number | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfInt32 {
        const json = this.toJSON();
        let result = new ApiResultOfInt32();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfInt32 {
    hasError: boolean | undefined;
    message: string | undefined;
    result: number | undefined;
    totalCount: number | undefined;
}

export class ApiResultOfMessageOut implements IApiResultOfMessageOut {
    hasError: boolean | undefined;
    message: string | undefined;
    result: MessageOut | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? MessageOut.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfMessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfMessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfMessageOut {
        const json = this.toJSON();
        let result = new ApiResultOfMessageOut();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfMessageOut {
    hasError: boolean | undefined;
    message: string | undefined;
    result: MessageOut | undefined;
    totalCount: number | undefined;
}

export class MessageOut implements IMessageOut {
    message: string | undefined;
    isSuccessful: boolean | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["Message"];
            this.isSuccessful = _data["IsSuccessful"];
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["IsSuccessful"] = this.isSuccessful;
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean | undefined;
}

export class ApiResultOfGetAccountDetailsResponse implements IApiResultOfGetAccountDetailsResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAccountDetailsResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetAccountDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetAccountDetailsResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetAccountDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetAccountDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetAccountDetailsResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetAccountDetailsResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetAccountDetailsResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAccountDetailsResponse | undefined;
    totalCount: number | undefined;
}

export class GetAccountDetailsResponse implements IGetAccountDetailsResponse {
    header: GetAccountDetailsResponseHeader | undefined;
    body: GetAccountDetailsResponseBody[] | undefined;

    constructor(data?: IGetAccountDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? GetAccountDetailsResponseHeader.fromJS(_data["header"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetAccountDetailsResponseBody.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAccountDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAccountDetailsResponse {
        const json = this.toJSON();
        let result = new GetAccountDetailsResponse();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailsResponse {
    header: GetAccountDetailsResponseHeader | undefined;
    body: GetAccountDetailsResponseBody[] | undefined;
}

export class GetAccountDetailsResponseHeader implements IGetAccountDetailsResponseHeader {
    audit: Audit | undefined;
    page_start: number | undefined;
    page_token: string | undefined;
    total_size: number | undefined;
    page_size: number | undefined;
    status: string | undefined;

    constructor(data?: IGetAccountDetailsResponseHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.page_start = _data["page_start"];
            this.page_token = _data["page_token"];
            this.total_size = _data["total_size"];
            this.page_size = _data["page_size"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetAccountDetailsResponseHeader {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailsResponseHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["page_start"] = this.page_start;
        data["page_token"] = this.page_token;
        data["total_size"] = this.total_size;
        data["page_size"] = this.page_size;
        data["status"] = this.status;
        return data; 
    }

    clone(): GetAccountDetailsResponseHeader {
        const json = this.toJSON();
        let result = new GetAccountDetailsResponseHeader();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailsResponseHeader {
    audit: Audit | undefined;
    page_start: number | undefined;
    page_token: string | undefined;
    total_size: number | undefined;
    page_size: number | undefined;
    status: string | undefined;
}

export class GetAccountDetailsResponseBody implements IGetAccountDetailsResponseBody {
    gender: string | undefined;
    accountName: string | undefined;
    accountCategory: string | undefined;
    shortAccount: string | undefined;
    dateOfBirth: string | undefined;
    sortCode: string | undefined;
    categoryDescription: string | undefined;
    accountStatus: string | undefined;
    longAccount: string | undefined;
    accountManager: string | undefined;
    isAccountChequeValid: boolean | undefined;
    bvn: string | undefined;
    accountBalance: string | undefined;
    bookBalance: string | undefined;
    currencyCode: string | undefined;

    constructor(data?: IGetAccountDetailsResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.accountName = _data["accountName"];
            this.accountCategory = _data["accountCategory"];
            this.shortAccount = _data["shortAccount"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.sortCode = _data["sortCode"];
            this.categoryDescription = _data["categoryDescription"];
            this.accountStatus = _data["accountStatus"];
            this.longAccount = _data["longAccount"];
            this.accountManager = _data["accountManager"];
            this.isAccountChequeValid = _data["isAccountChequeValid"];
            this.bvn = _data["bvn"];
            this.accountBalance = _data["accountBalance"];
            this.bookBalance = _data["bookBalance"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): GetAccountDetailsResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailsResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["accountName"] = this.accountName;
        data["accountCategory"] = this.accountCategory;
        data["shortAccount"] = this.shortAccount;
        data["dateOfBirth"] = this.dateOfBirth;
        data["sortCode"] = this.sortCode;
        data["categoryDescription"] = this.categoryDescription;
        data["accountStatus"] = this.accountStatus;
        data["longAccount"] = this.longAccount;
        data["accountManager"] = this.accountManager;
        data["isAccountChequeValid"] = this.isAccountChequeValid;
        data["bvn"] = this.bvn;
        data["accountBalance"] = this.accountBalance;
        data["bookBalance"] = this.bookBalance;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }

    clone(): GetAccountDetailsResponseBody {
        const json = this.toJSON();
        let result = new GetAccountDetailsResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailsResponseBody {
    gender: string | undefined;
    accountName: string | undefined;
    accountCategory: string | undefined;
    shortAccount: string | undefined;
    dateOfBirth: string | undefined;
    sortCode: string | undefined;
    categoryDescription: string | undefined;
    accountStatus: string | undefined;
    longAccount: string | undefined;
    accountManager: string | undefined;
    isAccountChequeValid: boolean | undefined;
    bvn: string | undefined;
    accountBalance: string | undefined;
    bookBalance: string | undefined;
    currencyCode: string | undefined;
}

export class Audit implements IAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;

    constructor(data?: IAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.t24_time = _data["T24_time"];
            this.responseParse_time = _data["responseParse_time"];
            this.requestParse_time = _data["requestParse_time"];
            this.versionNumber = _data["versionNumber"];
        }
    }

    static fromJS(data: any): Audit {
        data = typeof data === 'object' ? data : {};
        let result = new Audit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["T24_time"] = this.t24_time;
        data["responseParse_time"] = this.responseParse_time;
        data["requestParse_time"] = this.requestParse_time;
        data["versionNumber"] = this.versionNumber;
        return data; 
    }

    clone(): Audit {
        const json = this.toJSON();
        let result = new Audit();
        result.init(json);
        return result;
    }
}

export interface IAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;
}

export class NameEnquiryPayload implements INameEnquiryPayload {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    channelCode: string | undefined;

    constructor(data?: INameEnquiryPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationInstitutionCode = _data["destinationInstitutionCode"];
            this.accountNumber = _data["accountNumber"];
            this.channelCode = _data["ChannelCode"];
        }
    }

    static fromJS(data: any): NameEnquiryPayload {
        data = typeof data === 'object' ? data : {};
        let result = new NameEnquiryPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["destinationInstitutionCode"] = this.destinationInstitutionCode;
        data["accountNumber"] = this.accountNumber;
        data["ChannelCode"] = this.channelCode;
        return data; 
    }

    clone(): NameEnquiryPayload {
        const json = this.toJSON();
        let result = new NameEnquiryPayload();
        result.init(json);
        return result;
    }
}

export interface INameEnquiryPayload {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    channelCode: string | undefined;
}

export class ApiResultOfNameEnquiryResponse implements IApiResultOfNameEnquiryResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NameEnquiryResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfNameEnquiryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? NameEnquiryResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfNameEnquiryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfNameEnquiryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfNameEnquiryResponse {
        const json = this.toJSON();
        let result = new ApiResultOfNameEnquiryResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfNameEnquiryResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NameEnquiryResponse | undefined;
    totalCount: number | undefined;
}

export class NameEnquiryResponse implements INameEnquiryResponse {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    accountName: string | undefined;
    bankVerificationNo: string | undefined;
    kycLevel: string | undefined;
    responseCode: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;

    constructor(data?: INameEnquiryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationInstitutionCode = _data["DestinationInstitutionCode"];
            this.accountNumber = _data["AccountNumber"];
            this.accountName = _data["AccountName"];
            this.bankVerificationNo = _data["BankVerificationNo"];
            this.kycLevel = _data["KycLevel"];
            this.responseCode = _data["ResponseCode"];
            this.nameEnquiryRef = _data["NameEnquiryRef"];
            this.channelCode = _data["ChannelCode"];
        }
    }

    static fromJS(data: any): NameEnquiryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NameEnquiryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DestinationInstitutionCode"] = this.destinationInstitutionCode;
        data["AccountNumber"] = this.accountNumber;
        data["AccountName"] = this.accountName;
        data["BankVerificationNo"] = this.bankVerificationNo;
        data["KycLevel"] = this.kycLevel;
        data["ResponseCode"] = this.responseCode;
        data["NameEnquiryRef"] = this.nameEnquiryRef;
        data["ChannelCode"] = this.channelCode;
        return data; 
    }

    clone(): NameEnquiryResponse {
        const json = this.toJSON();
        let result = new NameEnquiryResponse();
        result.init(json);
        return result;
    }
}

export interface INameEnquiryResponse {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    accountName: string | undefined;
    bankVerificationNo: string | undefined;
    kycLevel: string | undefined;
    responseCode: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;
}

export class SingleBody implements ISingleBody {
    body: SingleGenericPayload | undefined;

    constructor(data?: ISingleBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? SingleGenericPayload.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleBody {
        data = typeof data === 'object' ? data : {};
        let result = new SingleBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SingleBody {
        const json = this.toJSON();
        let result = new SingleBody();
        result.init(json);
        return result;
    }
}

export interface ISingleBody {
    body: SingleGenericPayload | undefined;
}

export class SingleGenericPayload implements ISingleGenericPayload {
    debitAccount: string | undefined;
    amount: number | undefined;
    currency: string | undefined;
    creditAccount: string | undefined;
    channel: string | undefined;
    narration: string | undefined;

    constructor(data?: ISingleGenericPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debitAccount = _data["debitAccount"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.creditAccount = _data["creditAccount"];
            this.channel = _data["channel"];
            this.narration = _data["narration"];
        }
    }

    static fromJS(data: any): SingleGenericPayload {
        data = typeof data === 'object' ? data : {};
        let result = new SingleGenericPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debitAccount"] = this.debitAccount;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["creditAccount"] = this.creditAccount;
        data["channel"] = this.channel;
        data["narration"] = this.narration;
        return data; 
    }

    clone(): SingleGenericPayload {
        const json = this.toJSON();
        let result = new SingleGenericPayload();
        result.init(json);
        return result;
    }
}

export interface ISingleGenericPayload {
    debitAccount: string | undefined;
    amount: number | undefined;
    currency: string | undefined;
    creditAccount: string | undefined;
    channel: string | undefined;
    narration: string | undefined;
}

export class ApiResultOfRoot implements IApiResultOfRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: Root | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? Root.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfRoot {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfRoot {
        const json = this.toJSON();
        let result = new ApiResultOfRoot();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: Root | undefined;
    totalCount: number | undefined;
}

export class Root implements IRoot {
    header: Header | undefined;
    body: Body | undefined;

    constructor(data?: IRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? Header.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? Body.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Root {
        data = typeof data === 'object' ? data : {};
        let result = new Root();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Root {
        const json = this.toJSON();
        let result = new Root();
        result.init(json);
        return result;
    }
}

export interface IRoot {
    header: Header | undefined;
    body: Body | undefined;
}

export class Header implements IHeader {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: IHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Header {
        data = typeof data === 'object' ? data : {};
        let result = new Header();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): Header {
        const json = this.toJSON();
        let result = new Header();
        result.init(json);
        return result;
    }
}

export interface IHeader {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class Body implements IBody {
    amount: number | undefined;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    narration: string | undefined;
    channel: string | undefined;
    currency: string | undefined;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.debitAccount = _data["debitAccount"];
            this.creditAccount = _data["creditAccount"];
            this.narration = _data["narration"];
            this.channel = _data["channel"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["debitAccount"] = this.debitAccount;
        data["creditAccount"] = this.creditAccount;
        data["narration"] = this.narration;
        data["channel"] = this.channel;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): Body {
        const json = this.toJSON();
        let result = new Body();
        result.init(json);
        return result;
    }
}

export interface IBody {
    amount: number | undefined;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    narration: string | undefined;
    channel: string | undefined;
    currency: string | undefined;
}

export class Nptransfer implements INptransfer {
    body: Nptransferbody | undefined;

    constructor(data?: INptransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? Nptransferbody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Nptransfer {
        data = typeof data === 'object' ? data : {};
        let result = new Nptransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Nptransfer {
        const json = this.toJSON();
        let result = new Nptransfer();
        result.init(json);
        return result;
    }
}

export interface INptransfer {
    body: Nptransferbody | undefined;
}

export class Nptransferbody implements INptransferbody {
    beneficiaryAccountNo: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    amount: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;
    beneficiaryAccountName: string | undefined;
    channel: string | undefined;
    beneficiaryBVN: string | undefined;
    narration: string | undefined;
    originatorAccountNumber: string | undefined;

    constructor(data?: INptransferbody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beneficiaryAccountNo = _data["beneficiaryAccountNo"];
            this.externalBankCode = _data["externalBankCode"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
            this.nameEnquiryRef = _data["nameEnquiryRef"];
            this.channelCode = _data["channelCode"];
            this.beneficiaryAccountName = _data["beneficiaryAccountName"];
            this.channel = _data["channel"];
            this.beneficiaryBVN = _data["beneficiaryBVN"];
            this.narration = _data["narration"];
            this.originatorAccountNumber = _data["originatorAccountNumber"];
        }
    }

    static fromJS(data: any): Nptransferbody {
        data = typeof data === 'object' ? data : {};
        let result = new Nptransferbody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryAccountNo"] = this.beneficiaryAccountNo;
        data["externalBankCode"] = this.externalBankCode;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["nameEnquiryRef"] = this.nameEnquiryRef;
        data["channelCode"] = this.channelCode;
        data["beneficiaryAccountName"] = this.beneficiaryAccountName;
        data["channel"] = this.channel;
        data["beneficiaryBVN"] = this.beneficiaryBVN;
        data["narration"] = this.narration;
        data["originatorAccountNumber"] = this.originatorAccountNumber;
        return data; 
    }

    clone(): Nptransferbody {
        const json = this.toJSON();
        let result = new Nptransferbody();
        result.init(json);
        return result;
    }
}

export interface INptransferbody {
    beneficiaryAccountNo: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    amount: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;
    beneficiaryAccountName: string | undefined;
    channel: string | undefined;
    beneficiaryBVN: string | undefined;
    narration: string | undefined;
    originatorAccountNumber: string | undefined;
}

export class ApiResultOfNpRoot implements IApiResultOfNpRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NpRoot | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfNpRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? NpRoot.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfNpRoot {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfNpRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfNpRoot {
        const json = this.toJSON();
        let result = new ApiResultOfNpRoot();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfNpRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NpRoot | undefined;
    totalCount: number | undefined;
}

export class NpRoot implements INpRoot {
    linkedActivities: NpLinkedActivity[] | undefined;
    header: NpHeader | undefined;
    body: NpBody | undefined;

    constructor(data?: INpRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["linkedActivities"])) {
                this.linkedActivities = [] as any;
                for (let item of _data["linkedActivities"])
                    this.linkedActivities.push(NpLinkedActivity.fromJS(item));
            }
            this.header = _data["header"] ? NpHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? NpBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NpRoot {
        data = typeof data === 'object' ? data : {};
        let result = new NpRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.linkedActivities)) {
            data["linkedActivities"] = [];
            for (let item of this.linkedActivities)
                data["linkedActivities"].push(item.toJSON());
        }
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): NpRoot {
        const json = this.toJSON();
        let result = new NpRoot();
        result.init(json);
        return result;
    }
}

export interface INpRoot {
    linkedActivities: NpLinkedActivity[] | undefined;
    header: NpHeader | undefined;
    body: NpBody | undefined;
}

export class NpLinkedActivity implements INpLinkedActivity {
    header: NpHeader | undefined;
    body: NpBody | undefined;

    constructor(data?: INpLinkedActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? NpHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? NpBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NpLinkedActivity {
        data = typeof data === 'object' ? data : {};
        let result = new NpLinkedActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): NpLinkedActivity {
        const json = this.toJSON();
        let result = new NpLinkedActivity();
        result.init(json);
        return result;
    }
}

export interface INpLinkedActivity {
    header: NpHeader | undefined;
    body: NpBody | undefined;
}

export class NpHeader implements INpHeader {
    transactionStatus: string | undefined;
    audit: NpAudit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: INpHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? NpAudit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): NpHeader {
        data = typeof data === 'object' ? data : {};
        let result = new NpHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): NpHeader {
        const json = this.toJSON();
        let result = new NpHeader();
        result.init(json);
        return result;
    }
}

export interface INpHeader {
    transactionStatus: string | undefined;
    audit: NpAudit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class NpBody implements INpBody {
    arrangementId: string | undefined;
    activityId: string | undefined;
    productId: string | undefined;
    currencyId: string | undefined;
    effectiveDate: string | undefined;
    beneficiaryAccountNo: string | undefined;
    amount: string | undefined;
    channel: string | undefined;
    originatorBVN: string | undefined;
    beneficiaryBVN: string | undefined;
    beneficiaryAccountName: string | undefined;
    originatorAccountNumber: string | undefined;
    narration: string | undefined;
    nameEnquiryRef: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    originatorAccountName: string | undefined;
    channelCode: string | undefined;

    constructor(data?: INpBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.arrangementId = _data["arrangementId"];
            this.activityId = _data["activityId"];
            this.productId = _data["productId"];
            this.currencyId = _data["currencyId"];
            this.effectiveDate = _data["effectiveDate"];
            this.beneficiaryAccountNo = _data["beneficiaryAccountNo"];
            this.amount = _data["amount"];
            this.channel = _data["channel"];
            this.originatorBVN = _data["originatorBVN"];
            this.beneficiaryBVN = _data["beneficiaryBVN"];
            this.beneficiaryAccountName = _data["beneficiaryAccountName"];
            this.originatorAccountNumber = _data["originatorAccountNumber"];
            this.narration = _data["narration"];
            this.nameEnquiryRef = _data["nameEnquiryRef"];
            this.externalBankCode = _data["externalBankCode"];
            this.currency = _data["currency"];
            this.originatorAccountName = _data["originatorAccountName"];
            this.channelCode = _data["channelCode"];
        }
    }

    static fromJS(data: any): NpBody {
        data = typeof data === 'object' ? data : {};
        let result = new NpBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrangementId"] = this.arrangementId;
        data["activityId"] = this.activityId;
        data["productId"] = this.productId;
        data["currencyId"] = this.currencyId;
        data["effectiveDate"] = this.effectiveDate;
        data["beneficiaryAccountNo"] = this.beneficiaryAccountNo;
        data["amount"] = this.amount;
        data["channel"] = this.channel;
        data["originatorBVN"] = this.originatorBVN;
        data["beneficiaryBVN"] = this.beneficiaryBVN;
        data["beneficiaryAccountName"] = this.beneficiaryAccountName;
        data["originatorAccountNumber"] = this.originatorAccountNumber;
        data["narration"] = this.narration;
        data["nameEnquiryRef"] = this.nameEnquiryRef;
        data["externalBankCode"] = this.externalBankCode;
        data["currency"] = this.currency;
        data["originatorAccountName"] = this.originatorAccountName;
        data["channelCode"] = this.channelCode;
        return data; 
    }

    clone(): NpBody {
        const json = this.toJSON();
        let result = new NpBody();
        result.init(json);
        return result;
    }
}

export interface INpBody {
    arrangementId: string | undefined;
    activityId: string | undefined;
    productId: string | undefined;
    currencyId: string | undefined;
    effectiveDate: string | undefined;
    beneficiaryAccountNo: string | undefined;
    amount: string | undefined;
    channel: string | undefined;
    originatorBVN: string | undefined;
    beneficiaryBVN: string | undefined;
    beneficiaryAccountName: string | undefined;
    originatorAccountNumber: string | undefined;
    narration: string | undefined;
    nameEnquiryRef: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    originatorAccountName: string | undefined;
    channelCode: string | undefined;
}

export class NpAudit implements INpAudit {
    versionNumber: string | undefined;
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;

    constructor(data?: INpAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionNumber = _data["versionNumber"];
            this.t24_time = _data["T24_time"];
            this.responseParse_time = _data["responseParse_time"];
            this.requestParse_time = _data["requestParse_time"];
        }
    }

    static fromJS(data: any): NpAudit {
        data = typeof data === 'object' ? data : {};
        let result = new NpAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionNumber"] = this.versionNumber;
        data["T24_time"] = this.t24_time;
        data["responseParse_time"] = this.responseParse_time;
        data["requestParse_time"] = this.requestParse_time;
        return data; 
    }

    clone(): NpAudit {
        const json = this.toJSON();
        let result = new NpAudit();
        result.init(json);
        return result;
    }
}

export interface INpAudit {
    versionNumber: string | undefined;
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
}

export class CtRoot implements ICtRoot {
    body: CtBody | undefined;

    constructor(data?: ICtRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? CtBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CtRoot {
        data = typeof data === 'object' ? data : {};
        let result = new CtRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CtRoot {
        const json = this.toJSON();
        let result = new CtRoot();
        result.init(json);
        return result;
    }
}

export interface ICtRoot {
    body: CtBody | undefined;
}

export class CtBody implements ICtBody {
    denominationValues: DenominationValue[] | undefined;
    depositAmount: string | undefined;
    creditAccount: string | undefined;
    narrative: string | undefined;
    documentNo: string | undefined;
    channel: string | undefined;

    constructor(data?: ICtBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["denominationValues"])) {
                this.denominationValues = [] as any;
                for (let item of _data["denominationValues"])
                    this.denominationValues.push(DenominationValue.fromJS(item));
            }
            this.depositAmount = _data["depositAmount"];
            this.creditAccount = _data["creditAccount"];
            this.narrative = _data["narrative"];
            this.documentNo = _data["documentNo"];
            this.channel = _data["channel"];
        }
    }

    static fromJS(data: any): CtBody {
        data = typeof data === 'object' ? data : {};
        let result = new CtBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.denominationValues)) {
            data["denominationValues"] = [];
            for (let item of this.denominationValues)
                data["denominationValues"].push(item.toJSON());
        }
        data["depositAmount"] = this.depositAmount;
        data["creditAccount"] = this.creditAccount;
        data["narrative"] = this.narrative;
        data["documentNo"] = this.documentNo;
        data["channel"] = this.channel;
        return data; 
    }

    clone(): CtBody {
        const json = this.toJSON();
        let result = new CtBody();
        result.init(json);
        return result;
    }
}

export interface ICtBody {
    denominationValues: DenominationValue[] | undefined;
    depositAmount: string | undefined;
    creditAccount: string | undefined;
    narrative: string | undefined;
    documentNo: string | undefined;
    channel: string | undefined;
}

export class DenominationValue implements IDenominationValue {
    denomination: string | undefined;
    unit: string | undefined;

    constructor(data?: IDenominationValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.denomination = _data["denomination"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): DenominationValue {
        data = typeof data === 'object' ? data : {};
        let result = new DenominationValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denomination"] = this.denomination;
        data["unit"] = this.unit;
        return data; 
    }

    clone(): DenominationValue {
        const json = this.toJSON();
        let result = new DenominationValue();
        result.init(json);
        return result;
    }
}

export interface IDenominationValue {
    denomination: string | undefined;
    unit: string | undefined;
}

export class ApiResultOfCtRRoot implements IApiResultOfCtRRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: CtRRoot | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfCtRRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? CtRRoot.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfCtRRoot {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfCtRRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfCtRRoot {
        const json = this.toJSON();
        let result = new ApiResultOfCtRRoot();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfCtRRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: CtRRoot | undefined;
    totalCount: number | undefined;
}

export class CtRRoot implements ICtRRoot {
    header: CtHeader | undefined;
    body: CtBody | undefined;

    constructor(data?: ICtRRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? CtHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? CtBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CtRRoot {
        data = typeof data === 'object' ? data : {};
        let result = new CtRRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CtRRoot {
        const json = this.toJSON();
        let result = new CtRRoot();
        result.init(json);
        return result;
    }
}

export interface ICtRRoot {
    header: CtHeader | undefined;
    body: CtBody | undefined;
}

export class CtHeader implements ICtHeader {
    transactionStatus: string | undefined;
    audit: CtAudit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: ICtHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? CtAudit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CtHeader {
        data = typeof data === 'object' ? data : {};
        let result = new CtHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): CtHeader {
        const json = this.toJSON();
        let result = new CtHeader();
        result.init(json);
        return result;
    }
}

export interface ICtHeader {
    transactionStatus: string | undefined;
    audit: CtAudit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class CtAudit implements ICtAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;

    constructor(data?: ICtAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.t24_time = _data["T24_time"];
            this.responseParse_time = _data["responseParse_time"];
            this.requestParse_time = _data["requestParse_time"];
            this.versionNumber = _data["versionNumber"];
        }
    }

    static fromJS(data: any): CtAudit {
        data = typeof data === 'object' ? data : {};
        let result = new CtAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["T24_time"] = this.t24_time;
        data["responseParse_time"] = this.responseParse_time;
        data["requestParse_time"] = this.requestParse_time;
        data["versionNumber"] = this.versionNumber;
        return data; 
    }

    clone(): CtAudit {
        const json = this.toJSON();
        let result = new CtAudit();
        result.init(json);
        return result;
    }
}

export interface ICtAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}