/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { environment } from '../../environments/environment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : environment.urls.api_main;
    }

    /**
     * @param username (optional) 
     * @param isbackofficestaff (optional) 
     * @param getAll (optional) 
     * @return OK
     */
    getAllUsers(username: string | null | undefined, isbackofficestaff: boolean | null | undefined, getAll: number | null | undefined, session_token: string, imei: string): Observable<ApiResultOfIListOfUser> {
        let url_ = this.baseUrl + "/api/auth/GetAllUsers?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (isbackofficestaff !== undefined && isbackofficestaff !== null)
            url_ += "isbackofficestaff=" + encodeURIComponent("" + isbackofficestaff) + "&";
        if (getAll !== undefined && getAll !== null)
            url_ += "getAll=" + encodeURIComponent("" + getAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIListOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIListOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ApiResultOfIListOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIListOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIListOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    login(payload: UserLoginPayload, session_token: string, imei: string): Observable<ApiResultOfUser> {
        let url_ = this.baseUrl + "/api/auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ApiResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    refreshCustomerInfo(accountno: string, session_token: string, imei: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/auth/RefreshCustomerInfo?";
        if (accountno === undefined || accountno === null)
            throw new Error("The parameter 'accountno' must be defined and cannot be null.");
        else
            url_ += "accountno=" + encodeURIComponent("" + accountno) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshCustomerInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshCustomerInfo(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshCustomerInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return OK
     */
    validateToken(session_token: string, imei: string): Observable<ApiResultOfUser> {
        let url_ = this.baseUrl + "/api/auth/ValidateToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateToken(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processValidateToken(response: HttpResponseBase): Observable<ApiResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    logout(session_token: string, imei: string): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }

    /**
     * @return OK
     */
    changePassword(payload: ChangePINPayload, session_token: string, imei: string): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }

    /**
     * @return OK
     */
    sendOTP(username: string, session_token: string, imei: string): Observable<ApiResultOfInt32> {
        let url_ = this.baseUrl + "/api/auth/SendOTP?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOTP(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processSendOTP(response: HttpResponseBase): Observable<ApiResultOfInt32> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfInt32.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfInt32>(<any>null);
    }

    /**
     * @return OK
     */
    verifyOTP(username: string, otp: number, session_token: string, imei: string): Observable<ApiResultOfUser> {
        let url_ = this.baseUrl + "/api/auth/VerifyOTP?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (otp === undefined || otp === null)
            throw new Error("The parameter 'otp' must be defined and cannot be null.");
        else
            url_ += "otp=" + encodeURIComponent("" + otp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyOTP(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyOTP(response: HttpResponseBase): Observable<ApiResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    setNewPassword(payload: SetNewPINPayload, session_token: string, imei: string): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/SetNewPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNewPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNewPassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetNewPassword(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }

    /**
     * @return OK
     */
    saveUser(payload: User, session_token: string, imei: string): Observable<ApiResultOfUser> {
        let url_ = this.baseUrl + "/api/auth/SaveUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUser(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUser(response: HttpResponseBase): Observable<ApiResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUser>(<any>null);
    }

    /**
     * @return OK
     */
    setSessionData(payload: UserSessionState, session_token: string, imei: string): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/SetSessionData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetSessionData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetSessionData(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetSessionData(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }

    /**
     * @return OK
     */
    fetchSessionData(session_token: string, imei: string): Observable<ApiResultOfUserSessionState> {
        let url_ = this.baseUrl + "/api/auth/FetchSessionData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchSessionData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchSessionData(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUserSessionState>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUserSessionState>><any>_observableThrow(response_);
        }));
    }

    protected processFetchSessionData(response: HttpResponseBase): Observable<ApiResultOfUserSessionState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUserSessionState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUserSessionState>(<any>null);
    }
}

@Injectable()
export class LotusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : environment.urls.api_main;
    }

    /**
     * @return OK
     */
    getAccountDetails(accountno: string, session_token: string, imei: string): Observable<ApiResultOfGetAccountDetailsResponse> {
        let url_ = this.baseUrl + "/api/lotus/getAccountDetails?";
        if (accountno === undefined || accountno === null)
            throw new Error("The parameter 'accountno' must be defined and cannot be null.");
        else
            url_ += "accountno=" + encodeURIComponent("" + accountno) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountDetails(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetAccountDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetAccountDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountDetails(response: HttpResponseBase): Observable<ApiResultOfGetAccountDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetAccountDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetAccountDetailsResponse>(<any>null);
    }

    /**
     * @return OK
     */
    nameenquiry(payload: NameEnquiryPayload, session_token: string, imei: string): Observable<ApiResultOfNameEnquiryResponse> {
        let url_ = this.baseUrl + "/api/lotus/nameenquiry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNameenquiry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNameenquiry(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNameEnquiryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNameEnquiryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processNameenquiry(response: HttpResponseBase): Observable<ApiResultOfNameEnquiryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNameEnquiryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNameEnquiryResponse>(<any>null);
    }

    /**
     * @return OK
     */
    single(payload: SingleBody, session_token: string, imei: string): Observable<ApiResultOfRoot> {
        let url_ = this.baseUrl + "/api/lotus/single";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingle(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRoot>><any>_observableThrow(response_);
        }));
    }

    protected processSingle(response: HttpResponseBase): Observable<ApiResultOfRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRoot>(<any>null);
    }

    /**
     * @return OK
     */
    nipTransfer(payload: Nptransfer, session_token: string, imei: string): Observable<ApiResultOfNpRoot> {
        let url_ = this.baseUrl + "/api/lotus/nipTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNipTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNipTransfer(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNpRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNpRoot>><any>_observableThrow(response_);
        }));
    }

    protected processNipTransfer(response: HttpResponseBase): Observable<ApiResultOfNpRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNpRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNpRoot>(<any>null);
    }

    /**
     * @return OK
     */
    tellerCashDep(payload: CtRoot, session_token: string, imei: string): Observable<ApiResultOfCtRRoot> {
        let url_ = this.baseUrl + "/api/lotus/tellerCashDep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTellerCashDep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTellerCashDep(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfCtRRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfCtRRoot>><any>_observableThrow(response_);
        }));
    }

    protected processTellerCashDep(response: HttpResponseBase): Observable<ApiResultOfCtRRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfCtRRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfCtRRoot>(<any>null);
    }

    /**
     * @return OK
     */
    singleGenericCall(payload: SingleBody, session_token: string, imei: string): Observable<ApiResultOfRoot> {
        let url_ = this.baseUrl + "/api/lotus/SingleGenericCall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingleGenericCall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingleGenericCall(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRoot>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRoot>><any>_observableThrow(response_);
        }));
    }

    protected processSingleGenericCall(response: HttpResponseBase): Observable<ApiResultOfRoot> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRoot.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRoot>(<any>null);
    }

    /**
     * @return OK
     */
    fetchBanks(session_token: string, imei: string): Observable<ApiResultOfBankResponseModel> {
        let url_ = this.baseUrl + "/api/lotus/fetchBanks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchBanks(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBankResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBankResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processFetchBanks(response: HttpResponseBase): Observable<ApiResultOfBankResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBankResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBankResponseModel>(<any>null);
    }

    /**
     * @return OK
     */
    tellerCashWithdrawal(payload: CashWithdrawalModel, session_token: string, imei: string): Observable<ApiResultOfCashWithdrawalResponse> {
        let url_ = this.baseUrl + "/api/lotus/tellerCashWithdrawal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTellerCashWithdrawal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTellerCashWithdrawal(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfCashWithdrawalResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfCashWithdrawalResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTellerCashWithdrawal(response: HttpResponseBase): Observable<ApiResultOfCashWithdrawalResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfCashWithdrawalResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfCashWithdrawalResponse>(<any>null);
    }

    /**
     * @return OK
     */
    postChequeInward(payload: PostChequePayload, session_token: string, imei: string): Observable<ApiResultOfPostChequeResponse> {
        let url_ = this.baseUrl + "/api/lotus/postChequeInward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostChequeInward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostChequeInward(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPostChequeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPostChequeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPostChequeInward(response: HttpResponseBase): Observable<ApiResultOfPostChequeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPostChequeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPostChequeResponse>(<any>null);
    }

    /**
     * @return OK
     */
    authorizeInwardCheque(header_id: string, session_token: string, imei: string): Observable<ApiResultOfAuthorizeChequeResponse> {
        let url_ = this.baseUrl + "/api/lotus/authorizeInwardCheque?";
        if (header_id === undefined || header_id === null)
            throw new Error("The parameter 'header_id' must be defined and cannot be null.");
        else
            url_ += "header_id=" + encodeURIComponent("" + header_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorizeInwardCheque(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorizeInwardCheque(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfAuthorizeChequeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfAuthorizeChequeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthorizeInwardCheque(response: HttpResponseBase): Observable<ApiResultOfAuthorizeChequeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfAuthorizeChequeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfAuthorizeChequeResponse>(<any>null);
    }

    /**
     * @return OK
     */
    updateAccountInfo(payload: UpdateAccountInfoPayload, session_token: string, imei: string): Observable<ApiResultOfUpdateAccountInfoResponse> {
        let url_ = this.baseUrl + "/api/lotus/updateAccountInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountInfo(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUpdateAccountInfoResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUpdateAccountInfoResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountInfo(response: HttpResponseBase): Observable<ApiResultOfUpdateAccountInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUpdateAccountInfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUpdateAccountInfoResponse>(<any>null);
    }

    /**
     * @return OK
     */
    freezeAccount(payload: FreezeAccountPayload, session_token: string, imei: string): Observable<ApiResultOfFreezeAccountResponse> {
        let url_ = this.baseUrl + "/api/lotus/freezeAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFreezeAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFreezeAccount(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfFreezeAccountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfFreezeAccountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFreezeAccount(response: HttpResponseBase): Observable<ApiResultOfFreezeAccountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfFreezeAccountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfFreezeAccountResponse>(<any>null);
    }

    /**
     * @return OK
     */
    getAccountStatement(payload: GetAccountStatementPayload, session_token: string, imei: string): Observable<ApiResultOfGetAccountStatementResponse> {
        let url_ = this.baseUrl + "/api/lotus/getAccountStatement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountStatement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountStatement(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetAccountStatementResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetAccountStatementResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountStatement(response: HttpResponseBase): Observable<ApiResultOfGetAccountStatementResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetAccountStatementResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetAccountStatementResponse>(<any>null);
    }

    /**
     * @param categoryId (optional) 
     * @param displayName (optional) 
     * @param productId (optional) 
     * @return OK
     */
    getAcctCategories(categoryId: string | null | undefined, displayName: string | null | undefined, productId: string | null | undefined, session_token: string, imei: string): Observable<ApiResultOfGetAcctCategoriesResponse> {
        let url_ = this.baseUrl + "/api/lotus/getAcctCategories?";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (displayName !== undefined && displayName !== null)
            url_ += "displayName=" + encodeURIComponent("" + displayName) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAcctCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAcctCategories(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetAcctCategoriesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetAcctCategoriesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAcctCategories(response: HttpResponseBase): Observable<ApiResultOfGetAcctCategoriesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetAcctCategoriesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetAcctCategoriesResponse>(<any>null);
    }

    /**
     * @return OK
     */
    getSectorList(session_token: string, imei: string): Observable<ApiResultOfGetSectorListResponse> {
        let url_ = this.baseUrl + "/api/lotus/getSectorList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectorList(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetSectorListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetSectorListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSectorList(response: HttpResponseBase): Observable<ApiResultOfGetSectorListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetSectorListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetSectorListResponse>(<any>null);
    }

    /**
     * @param product (optional) 
     * @param productGroup (optional) 
     * @return OK
     */
    getProductList(product: string | null | undefined, productGroup: string | null | undefined, session_token: string, imei: string): Observable<ApiResultOfGetProductListResponse> {
        let url_ = this.baseUrl + "/api/lotus/getProductList?";
        if (product !== undefined && product !== null)
            url_ += "product=" + encodeURIComponent("" + product) + "&";
        if (productGroup !== undefined && productGroup !== null)
            url_ += "productGroup=" + encodeURIComponent("" + productGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductList(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetProductListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetProductListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductList(response: HttpResponseBase): Observable<ApiResultOfGetProductListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetProductListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetProductListResponse>(<any>null);
    }

    /**
     * @return OK
     */
    getIndustryList(session_token: string, imei: string): Observable<ApiResultOfGetIndustryListResponse> {
        let url_ = this.baseUrl + "/api/lotus/getIndustryList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustryList(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGetIndustryListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGetIndustryListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustryList(response: HttpResponseBase): Observable<ApiResultOfGetIndustryListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGetIndustryListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGetIndustryListResponse>(<any>null);
    }

    /**
     * @return OK
     */
    createAccountsLtb(payload: CreateCustomerModelBody, session_token: string, imei: string): Observable<ApiResultOfHeader2> {
        let url_ = this.baseUrl + "/api/lotus/CreateAccountsLtb";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountsLtb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountsLtb(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfHeader2>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfHeader2>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccountsLtb(response: HttpResponseBase): Observable<ApiResultOfHeader2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfHeader2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfHeader2>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : environment.urls.api_main;
    }

    /**
     * @return OK
     */
    valuesGetToken(session_token: string, imei: string): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesGetToken(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processValuesGetToken(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return No Content
     */
    valuesPost(value: string, session_token: string, imei: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValuesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return OK
     */
    valuesGet(id: number, session_token: string, imei: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesGet(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processValuesGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return No Content
     */
    valuesPut(id: number, value: string, session_token: string, imei: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValuesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return No Content
     */
    valuesDelete(id: number, session_token: string, imei: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "session_token": session_token !== undefined && session_token !== null ? "" + session_token : "",
                "imei": imei !== undefined && imei !== null ? "" + imei : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValuesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValuesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValuesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class ApiResultOfIListOfUser implements IApiResultOfIListOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User[] | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfIListOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Result"])) {
                this.result = [] as any;
                for (let item of _data["Result"])
                    this.result.push(User.fromJS(item));
            }
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfIListOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIListOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        if (Array.isArray(this.result)) {
            data["Result"] = [];
            for (let item of this.result)
                data["Result"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfIListOfUser {
        const json = this.toJSON();
        let result = new ApiResultOfIListOfUser();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfIListOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User[] | undefined;
    totalCount: number | undefined;
}

export class User implements IUser {
    id: number | undefined;
    username: string | undefined;
    pINHash: string | undefined;
    pIN: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    phoneNo: string | undefined;
    dOB: string | undefined;
    oTP: number | undefined;
    oTPExpiryDate: Date | undefined;
    sessionToken: string | undefined;
    sessionTokenExpiry: Date | undefined;
    isBackOfficeStaff: boolean | undefined;
    secretQuestion: string | undefined;
    secretAnswer: string | undefined;
    roleName: string | undefined;
    branchCode: string | undefined;
    isActive: boolean | undefined;
    userAccounts: UserAccount[] | undefined;
    userRoles: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.username = _data["Username"];
            this.pINHash = _data["PINHash"];
            this.pIN = _data["PIN"];
            this.fullName = _data["FullName"];
            this.emailAddress = _data["EmailAddress"];
            this.phoneNo = _data["PhoneNo"];
            this.dOB = _data["DOB"];
            this.oTP = _data["OTP"];
            this.oTPExpiryDate = _data["OTPExpiryDate"] ? new Date(_data["OTPExpiryDate"].toString()) : <any>undefined;
            this.sessionToken = _data["SessionToken"];
            this.sessionTokenExpiry = _data["SessionTokenExpiry"] ? new Date(_data["SessionTokenExpiry"].toString()) : <any>undefined;
            this.isBackOfficeStaff = _data["IsBackOfficeStaff"];
            this.secretQuestion = _data["SecretQuestion"];
            this.secretAnswer = _data["SecretAnswer"];
            this.roleName = _data["RoleName"];
            this.branchCode = _data["BranchCode"];
            this.isActive = _data["IsActive"];
            if (Array.isArray(_data["UserAccounts"])) {
                this.userAccounts = [] as any;
                for (let item of _data["UserAccounts"])
                    this.userAccounts.push(UserAccount.fromJS(item));
            }
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Username"] = this.username;
        data["PINHash"] = this.pINHash;
        data["PIN"] = this.pIN;
        data["FullName"] = this.fullName;
        data["EmailAddress"] = this.emailAddress;
        data["PhoneNo"] = this.phoneNo;
        data["DOB"] = this.dOB;
        data["OTP"] = this.oTP;
        data["OTPExpiryDate"] = this.oTPExpiryDate ? this.oTPExpiryDate.toISOString() : <any>undefined;
        data["SessionToken"] = this.sessionToken;
        data["SessionTokenExpiry"] = this.sessionTokenExpiry ? this.sessionTokenExpiry.toISOString() : <any>undefined;
        data["IsBackOfficeStaff"] = this.isBackOfficeStaff;
        data["SecretQuestion"] = this.secretQuestion;
        data["SecretAnswer"] = this.secretAnswer;
        data["RoleName"] = this.roleName;
        data["BranchCode"] = this.branchCode;
        data["IsActive"] = this.isActive;
        if (Array.isArray(this.userAccounts)) {
            data["UserAccounts"] = [];
            for (let item of this.userAccounts)
                data["UserAccounts"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number | undefined;
    username: string | undefined;
    pINHash: string | undefined;
    pIN: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    phoneNo: string | undefined;
    dOB: string | undefined;
    oTP: number | undefined;
    oTPExpiryDate: Date | undefined;
    sessionToken: string | undefined;
    sessionTokenExpiry: Date | undefined;
    isBackOfficeStaff: boolean | undefined;
    secretQuestion: string | undefined;
    secretAnswer: string | undefined;
    roleName: string | undefined;
    branchCode: string | undefined;
    isActive: boolean | undefined;
    userAccounts: UserAccount[] | undefined;
    userRoles: UserRole[] | undefined;
}

export class UserAccount implements IUserAccount {
    id: number | undefined;
    userId: number | undefined;
    accountNo: string | undefined;
    accountType: string | undefined;
    accountName: string | undefined;
    isDefault: boolean | undefined;
    isActive: boolean | undefined;

    constructor(data?: IUserAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.accountNo = _data["AccountNo"];
            this.accountType = _data["AccountType"];
            this.accountName = _data["AccountName"];
            this.isDefault = _data["IsDefault"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): UserAccount {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["AccountNo"] = this.accountNo;
        data["AccountType"] = this.accountType;
        data["AccountName"] = this.accountName;
        data["IsDefault"] = this.isDefault;
        data["IsActive"] = this.isActive;
        return data; 
    }

    clone(): UserAccount {
        const json = this.toJSON();
        let result = new UserAccount();
        result.init(json);
        return result;
    }
}

export interface IUserAccount {
    id: number | undefined;
    userId: number | undefined;
    accountNo: string | undefined;
    accountType: string | undefined;
    accountName: string | undefined;
    isDefault: boolean | undefined;
    isActive: boolean | undefined;
}

export class UserRole implements IUserRole {
    id: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    role: Role | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    role: Role | undefined;
}

export class Role implements IRole {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        return data; 
    }

    clone(): Role {
        const json = this.toJSON();
        let result = new Role();
        result.init(json);
        return result;
    }
}

export interface IRole {
    id: number | undefined;
    name: string | undefined;
}

export class UserLoginPayload implements IUserLoginPayload {
    username: string | undefined;
    pIN: string | undefined;
    oTP: number | undefined;
    authMode: string | undefined;
    dOB: string | undefined;

    constructor(data?: IUserLoginPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["Username"];
            this.pIN = _data["PIN"];
            this.oTP = _data["OTP"];
            this.authMode = _data["AuthMode"];
            this.dOB = _data["DOB"];
        }
    }

    static fromJS(data: any): UserLoginPayload {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Username"] = this.username;
        data["PIN"] = this.pIN;
        data["OTP"] = this.oTP;
        data["AuthMode"] = this.authMode;
        data["DOB"] = this.dOB;
        return data; 
    }

    clone(): UserLoginPayload {
        const json = this.toJSON();
        let result = new UserLoginPayload();
        result.init(json);
        return result;
    }
}

export interface IUserLoginPayload {
    username: string | undefined;
    pIN: string | undefined;
    oTP: number | undefined;
    authMode: string | undefined;
    dOB: string | undefined;
}

export class ApiResultOfUser implements IApiResultOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? User.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfUser {
        const json = this.toJSON();
        let result = new ApiResultOfUser();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfUser {
    hasError: boolean | undefined;
    message: string | undefined;
    result: User | undefined;
    totalCount: number | undefined;
}

export class ApiResultOfBoolean implements IApiResultOfBoolean {
    hasError: boolean | undefined;
    message: string | undefined;
    result: boolean | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfBoolean {
        const json = this.toJSON();
        let result = new ApiResultOfBoolean();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfBoolean {
    hasError: boolean | undefined;
    message: string | undefined;
    result: boolean | undefined;
    totalCount: number | undefined;
}

export class ChangePINPayload implements IChangePINPayload {
    currentPIN: string | undefined;
    newPIN: string | undefined;

    constructor(data?: IChangePINPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPIN = _data["CurrentPIN"];
            this.newPIN = _data["NewPIN"];
        }
    }

    static fromJS(data: any): ChangePINPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePINPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CurrentPIN"] = this.currentPIN;
        data["NewPIN"] = this.newPIN;
        return data; 
    }

    clone(): ChangePINPayload {
        const json = this.toJSON();
        let result = new ChangePINPayload();
        result.init(json);
        return result;
    }
}

export interface IChangePINPayload {
    currentPIN: string | undefined;
    newPIN: string | undefined;
}

export class ApiResultOfInt32 implements IApiResultOfInt32 {
    hasError: boolean | undefined;
    message: string | undefined;
    result: number | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfInt32 {
        const json = this.toJSON();
        let result = new ApiResultOfInt32();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfInt32 {
    hasError: boolean | undefined;
    message: string | undefined;
    result: number | undefined;
    totalCount: number | undefined;
}

export class SetNewPINPayload implements ISetNewPINPayload {
    id: number | undefined;
    newPIN: string | undefined;
    secretQuestion: string | undefined;
    secretAnswer: string | undefined;

    constructor(data?: ISetNewPINPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.newPIN = _data["NewPIN"];
            this.secretQuestion = _data["SecretQuestion"];
            this.secretAnswer = _data["SecretAnswer"];
        }
    }

    static fromJS(data: any): SetNewPINPayload {
        data = typeof data === 'object' ? data : {};
        let result = new SetNewPINPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NewPIN"] = this.newPIN;
        data["SecretQuestion"] = this.secretQuestion;
        data["SecretAnswer"] = this.secretAnswer;
        return data; 
    }

    clone(): SetNewPINPayload {
        const json = this.toJSON();
        let result = new SetNewPINPayload();
        result.init(json);
        return result;
    }
}

export interface ISetNewPINPayload {
    id: number | undefined;
    newPIN: string | undefined;
    secretQuestion: string | undefined;
    secretAnswer: string | undefined;
}

export class UserSessionState implements IUserSessionState {
    id: number | undefined;
    userId: number | undefined;
    lastBranchCode: string | undefined;
    sessionData: string | undefined;
    timestamp: Date | undefined;

    constructor(data?: IUserSessionState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.lastBranchCode = _data["LastBranchCode"];
            this.sessionData = _data["SessionData"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserSessionState {
        data = typeof data === 'object' ? data : {};
        let result = new UserSessionState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["LastBranchCode"] = this.lastBranchCode;
        data["SessionData"] = this.sessionData;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserSessionState {
        const json = this.toJSON();
        let result = new UserSessionState();
        result.init(json);
        return result;
    }
}

export interface IUserSessionState {
    id: number | undefined;
    userId: number | undefined;
    lastBranchCode: string | undefined;
    sessionData: string | undefined;
    timestamp: Date | undefined;
}

export class ApiResultOfUserSessionState implements IApiResultOfUserSessionState {
    hasError: boolean | undefined;
    message: string | undefined;
    result: UserSessionState | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfUserSessionState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? UserSessionState.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfUserSessionState {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUserSessionState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfUserSessionState {
        const json = this.toJSON();
        let result = new ApiResultOfUserSessionState();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfUserSessionState {
    hasError: boolean | undefined;
    message: string | undefined;
    result: UserSessionState | undefined;
    totalCount: number | undefined;
}

export class ApiResultOfGetAccountDetailsResponse implements IApiResultOfGetAccountDetailsResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAccountDetailsResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetAccountDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetAccountDetailsResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetAccountDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetAccountDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetAccountDetailsResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetAccountDetailsResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetAccountDetailsResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAccountDetailsResponse | undefined;
    totalCount: number | undefined;
}

export class GetAccountDetailsResponse implements IGetAccountDetailsResponse {
    header: GetAccountDetailsResponseHeader | undefined;
    body: GetAccountDetailsResponseBody[] | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IGetAccountDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? GetAccountDetailsResponseHeader.fromJS(_data["header"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetAccountDetailsResponseBody.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetAccountDetailsResponse {
        const json = this.toJSON();
        let result = new GetAccountDetailsResponse();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailsResponse {
    header: GetAccountDetailsResponseHeader | undefined;
    body: GetAccountDetailsResponseBody[] | undefined;
    error: ErrorDto | undefined;
}

export class GetAccountDetailsResponseHeader implements IGetAccountDetailsResponseHeader {
    audit: Audit | undefined;
    page_start: number | undefined;
    page_token: string | undefined;
    total_size: number | undefined;
    page_size: number | undefined;
    status: string | undefined;

    constructor(data?: IGetAccountDetailsResponseHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.page_start = _data["page_start"];
            this.page_token = _data["page_token"];
            this.total_size = _data["total_size"];
            this.page_size = _data["page_size"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetAccountDetailsResponseHeader {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailsResponseHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["page_start"] = this.page_start;
        data["page_token"] = this.page_token;
        data["total_size"] = this.total_size;
        data["page_size"] = this.page_size;
        data["status"] = this.status;
        return data; 
    }

    clone(): GetAccountDetailsResponseHeader {
        const json = this.toJSON();
        let result = new GetAccountDetailsResponseHeader();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailsResponseHeader {
    audit: Audit | undefined;
    page_start: number | undefined;
    page_token: string | undefined;
    total_size: number | undefined;
    page_size: number | undefined;
    status: string | undefined;
}

export class GetAccountDetailsResponseBody implements IGetAccountDetailsResponseBody {
    gender: string | undefined;
    accountName: string | undefined;
    accountCategory: string | undefined;
    shortAccount: string | undefined;
    dateOfBirth: string | undefined;
    sortCode: string | undefined;
    categoryDescription: string | undefined;
    accountStatus: string | undefined;
    longAccount: string | undefined;
    accountManager: string | undefined;
    isAccountChequeValid: boolean | undefined;
    bvn: string | undefined;
    accountBalance: string | undefined;
    bookBalance: string | undefined;
    currencyCode: string | undefined;
    customerPhone: string | undefined;

    constructor(data?: IGetAccountDetailsResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.accountName = _data["accountName"];
            this.accountCategory = _data["accountCategory"];
            this.shortAccount = _data["shortAccount"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.sortCode = _data["sortCode"];
            this.categoryDescription = _data["categoryDescription"];
            this.accountStatus = _data["accountStatus"];
            this.longAccount = _data["longAccount"];
            this.accountManager = _data["accountManager"];
            this.isAccountChequeValid = _data["isAccountChequeValid"];
            this.bvn = _data["bvn"];
            this.accountBalance = _data["accountBalance"];
            this.bookBalance = _data["bookBalance"];
            this.currencyCode = _data["currencyCode"];
            this.customerPhone = _data["customerPhone"];
        }
    }

    static fromJS(data: any): GetAccountDetailsResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailsResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["accountName"] = this.accountName;
        data["accountCategory"] = this.accountCategory;
        data["shortAccount"] = this.shortAccount;
        data["dateOfBirth"] = this.dateOfBirth;
        data["sortCode"] = this.sortCode;
        data["categoryDescription"] = this.categoryDescription;
        data["accountStatus"] = this.accountStatus;
        data["longAccount"] = this.longAccount;
        data["accountManager"] = this.accountManager;
        data["isAccountChequeValid"] = this.isAccountChequeValid;
        data["bvn"] = this.bvn;
        data["accountBalance"] = this.accountBalance;
        data["bookBalance"] = this.bookBalance;
        data["currencyCode"] = this.currencyCode;
        data["customerPhone"] = this.customerPhone;
        return data; 
    }

    clone(): GetAccountDetailsResponseBody {
        const json = this.toJSON();
        let result = new GetAccountDetailsResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailsResponseBody {
    gender: string | undefined;
    accountName: string | undefined;
    accountCategory: string | undefined;
    shortAccount: string | undefined;
    dateOfBirth: string | undefined;
    sortCode: string | undefined;
    categoryDescription: string | undefined;
    accountStatus: string | undefined;
    longAccount: string | undefined;
    accountManager: string | undefined;
    isAccountChequeValid: boolean | undefined;
    bvn: string | undefined;
    accountBalance: string | undefined;
    bookBalance: string | undefined;
    currencyCode: string | undefined;
    customerPhone: string | undefined;
}

export class ErrorDto implements IErrorDto {
    errorDetails: ErrorDetail[] | undefined;
    type: string | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errorDetails"])) {
                this.errorDetails = [] as any;
                for (let item of _data["errorDetails"])
                    this.errorDetails.push(ErrorDetail.fromJS(item));
            }
            this.type = _data["type"];
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errorDetails)) {
            data["errorDetails"] = [];
            for (let item of this.errorDetails)
                data["errorDetails"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ErrorDto {
        const json = this.toJSON();
        let result = new ErrorDto();
        result.init(json);
        return result;
    }
}

export interface IErrorDto {
    errorDetails: ErrorDetail[] | undefined;
    type: string | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class Audit implements IAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;

    constructor(data?: IAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.t24_time = _data["T24_time"];
            this.responseParse_time = _data["responseParse_time"];
            this.requestParse_time = _data["requestParse_time"];
            this.versionNumber = _data["versionNumber"];
        }
    }

    static fromJS(data: any): Audit {
        data = typeof data === 'object' ? data : {};
        let result = new Audit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["T24_time"] = this.t24_time;
        data["responseParse_time"] = this.responseParse_time;
        data["requestParse_time"] = this.requestParse_time;
        data["versionNumber"] = this.versionNumber;
        return data; 
    }

    clone(): Audit {
        const json = this.toJSON();
        let result = new Audit();
        result.init(json);
        return result;
    }
}

export interface IAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;
}

export class ErrorDetail implements IErrorDetail {
    fieldName: string | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IErrorDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ErrorDetail {
        const json = this.toJSON();
        let result = new ErrorDetail();
        result.init(json);
        return result;
    }
}

export interface IErrorDetail {
    fieldName: string | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class NameEnquiryPayload implements INameEnquiryPayload {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    channelCode: string | undefined;

    constructor(data?: INameEnquiryPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationInstitutionCode = _data["destinationInstitutionCode"];
            this.accountNumber = _data["accountNumber"];
            this.channelCode = _data["ChannelCode"];
        }
    }

    static fromJS(data: any): NameEnquiryPayload {
        data = typeof data === 'object' ? data : {};
        let result = new NameEnquiryPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["destinationInstitutionCode"] = this.destinationInstitutionCode;
        data["accountNumber"] = this.accountNumber;
        data["ChannelCode"] = this.channelCode;
        return data; 
    }

    clone(): NameEnquiryPayload {
        const json = this.toJSON();
        let result = new NameEnquiryPayload();
        result.init(json);
        return result;
    }
}

export interface INameEnquiryPayload {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    channelCode: string | undefined;
}

export class ApiResultOfNameEnquiryResponse implements IApiResultOfNameEnquiryResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NameEnquiryResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfNameEnquiryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? NameEnquiryResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfNameEnquiryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfNameEnquiryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfNameEnquiryResponse {
        const json = this.toJSON();
        let result = new ApiResultOfNameEnquiryResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfNameEnquiryResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NameEnquiryResponse | undefined;
    totalCount: number | undefined;
}

export class NameEnquiryResponse implements INameEnquiryResponse {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    accountName: string | undefined;
    bankVerificationNo: string | undefined;
    kycLevel: string | undefined;
    responseCode: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;

    constructor(data?: INameEnquiryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationInstitutionCode = _data["DestinationInstitutionCode"];
            this.accountNumber = _data["AccountNumber"];
            this.accountName = _data["AccountName"];
            this.bankVerificationNo = _data["BankVerificationNo"];
            this.kycLevel = _data["KycLevel"];
            this.responseCode = _data["ResponseCode"];
            this.nameEnquiryRef = _data["NameEnquiryRef"];
            this.channelCode = _data["ChannelCode"];
        }
    }

    static fromJS(data: any): NameEnquiryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NameEnquiryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DestinationInstitutionCode"] = this.destinationInstitutionCode;
        data["AccountNumber"] = this.accountNumber;
        data["AccountName"] = this.accountName;
        data["BankVerificationNo"] = this.bankVerificationNo;
        data["KycLevel"] = this.kycLevel;
        data["ResponseCode"] = this.responseCode;
        data["NameEnquiryRef"] = this.nameEnquiryRef;
        data["ChannelCode"] = this.channelCode;
        return data; 
    }

    clone(): NameEnquiryResponse {
        const json = this.toJSON();
        let result = new NameEnquiryResponse();
        result.init(json);
        return result;
    }
}

export interface INameEnquiryResponse {
    destinationInstitutionCode: string | undefined;
    accountNumber: string | undefined;
    accountName: string | undefined;
    bankVerificationNo: string | undefined;
    kycLevel: string | undefined;
    responseCode: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;
}

export class SingleBody implements ISingleBody {
    body: SingleGenericPayload | undefined;

    constructor(data?: ISingleBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? SingleGenericPayload.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleBody {
        data = typeof data === 'object' ? data : {};
        let result = new SingleBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SingleBody {
        const json = this.toJSON();
        let result = new SingleBody();
        result.init(json);
        return result;
    }
}

export interface ISingleBody {
    body: SingleGenericPayload | undefined;
}

export class SingleGenericPayload implements ISingleGenericPayload {
    debitAccount: string | undefined;
    amount: number | undefined;
    currency: string | undefined;
    creditAccount: string | undefined;
    channel: string | undefined;
    narration: string | undefined;

    constructor(data?: ISingleGenericPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debitAccount = _data["debitAccount"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.creditAccount = _data["creditAccount"];
            this.channel = _data["channel"];
            this.narration = _data["narration"];
        }
    }

    static fromJS(data: any): SingleGenericPayload {
        data = typeof data === 'object' ? data : {};
        let result = new SingleGenericPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debitAccount"] = this.debitAccount;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["creditAccount"] = this.creditAccount;
        data["channel"] = this.channel;
        data["narration"] = this.narration;
        return data; 
    }

    clone(): SingleGenericPayload {
        const json = this.toJSON();
        let result = new SingleGenericPayload();
        result.init(json);
        return result;
    }
}

export interface ISingleGenericPayload {
    debitAccount: string | undefined;
    amount: number | undefined;
    currency: string | undefined;
    creditAccount: string | undefined;
    channel: string | undefined;
    narration: string | undefined;
}

export class ApiResultOfRoot implements IApiResultOfRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: Root | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? Root.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfRoot {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfRoot {
        const json = this.toJSON();
        let result = new ApiResultOfRoot();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: Root | undefined;
    totalCount: number | undefined;
}

export class Root implements IRoot {
    header: Header | undefined;
    body: Body | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? Header.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? Body.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Root {
        data = typeof data === 'object' ? data : {};
        let result = new Root();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Root {
        const json = this.toJSON();
        let result = new Root();
        result.init(json);
        return result;
    }
}

export interface IRoot {
    header: Header | undefined;
    body: Body | undefined;
    error: ErrorDto | undefined;
}

export class Header implements IHeader {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: IHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Header {
        data = typeof data === 'object' ? data : {};
        let result = new Header();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): Header {
        const json = this.toJSON();
        let result = new Header();
        result.init(json);
        return result;
    }
}

export interface IHeader {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class Body implements IBody {
    amount: number | undefined;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    narration: string | undefined;
    channel: string | undefined;
    currency: string | undefined;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.debitAccount = _data["debitAccount"];
            this.creditAccount = _data["creditAccount"];
            this.narration = _data["narration"];
            this.channel = _data["channel"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["debitAccount"] = this.debitAccount;
        data["creditAccount"] = this.creditAccount;
        data["narration"] = this.narration;
        data["channel"] = this.channel;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): Body {
        const json = this.toJSON();
        let result = new Body();
        result.init(json);
        return result;
    }
}

export interface IBody {
    amount: number | undefined;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    narration: string | undefined;
    channel: string | undefined;
    currency: string | undefined;
}

export class Nptransfer implements INptransfer {
    body: Nptransferbody | undefined;

    constructor(data?: INptransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? Nptransferbody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Nptransfer {
        data = typeof data === 'object' ? data : {};
        let result = new Nptransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Nptransfer {
        const json = this.toJSON();
        let result = new Nptransfer();
        result.init(json);
        return result;
    }
}

export interface INptransfer {
    body: Nptransferbody | undefined;
}

export class Nptransferbody implements INptransferbody {
    beneficiaryAccountNo: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    amount: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;
    beneficiaryAccountName: string | undefined;
    channel: string | undefined;
    beneficiaryBVN: string | undefined;
    narration: string | undefined;
    originatorAccountNumber: string | undefined;

    constructor(data?: INptransferbody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beneficiaryAccountNo = _data["beneficiaryAccountNo"];
            this.externalBankCode = _data["externalBankCode"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
            this.nameEnquiryRef = _data["nameEnquiryRef"];
            this.channelCode = _data["channelCode"];
            this.beneficiaryAccountName = _data["beneficiaryAccountName"];
            this.channel = _data["channel"];
            this.beneficiaryBVN = _data["beneficiaryBVN"];
            this.narration = _data["narration"];
            this.originatorAccountNumber = _data["originatorAccountNumber"];
        }
    }

    static fromJS(data: any): Nptransferbody {
        data = typeof data === 'object' ? data : {};
        let result = new Nptransferbody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryAccountNo"] = this.beneficiaryAccountNo;
        data["externalBankCode"] = this.externalBankCode;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["nameEnquiryRef"] = this.nameEnquiryRef;
        data["channelCode"] = this.channelCode;
        data["beneficiaryAccountName"] = this.beneficiaryAccountName;
        data["channel"] = this.channel;
        data["beneficiaryBVN"] = this.beneficiaryBVN;
        data["narration"] = this.narration;
        data["originatorAccountNumber"] = this.originatorAccountNumber;
        return data; 
    }

    clone(): Nptransferbody {
        const json = this.toJSON();
        let result = new Nptransferbody();
        result.init(json);
        return result;
    }
}

export interface INptransferbody {
    beneficiaryAccountNo: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    amount: string | undefined;
    nameEnquiryRef: string | undefined;
    channelCode: string | undefined;
    beneficiaryAccountName: string | undefined;
    channel: string | undefined;
    beneficiaryBVN: string | undefined;
    narration: string | undefined;
    originatorAccountNumber: string | undefined;
}

export class ApiResultOfNpRoot implements IApiResultOfNpRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NpRoot | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfNpRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? NpRoot.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfNpRoot {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfNpRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfNpRoot {
        const json = this.toJSON();
        let result = new ApiResultOfNpRoot();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfNpRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: NpRoot | undefined;
    totalCount: number | undefined;
}

export class NpRoot implements INpRoot {
    linkedActivities: NpLinkedActivity[] | undefined;
    header: NpHeader | undefined;
    body: NpBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: INpRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["linkedActivities"])) {
                this.linkedActivities = [] as any;
                for (let item of _data["linkedActivities"])
                    this.linkedActivities.push(NpLinkedActivity.fromJS(item));
            }
            this.header = _data["header"] ? NpHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? NpBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NpRoot {
        data = typeof data === 'object' ? data : {};
        let result = new NpRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.linkedActivities)) {
            data["linkedActivities"] = [];
            for (let item of this.linkedActivities)
                data["linkedActivities"].push(item.toJSON());
        }
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): NpRoot {
        const json = this.toJSON();
        let result = new NpRoot();
        result.init(json);
        return result;
    }
}

export interface INpRoot {
    linkedActivities: NpLinkedActivity[] | undefined;
    header: NpHeader | undefined;
    body: NpBody | undefined;
    error: ErrorDto | undefined;
}

export class NpLinkedActivity implements INpLinkedActivity {
    header: NpHeader | undefined;
    body: NpBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: INpLinkedActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? NpHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? NpBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NpLinkedActivity {
        data = typeof data === 'object' ? data : {};
        let result = new NpLinkedActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): NpLinkedActivity {
        const json = this.toJSON();
        let result = new NpLinkedActivity();
        result.init(json);
        return result;
    }
}

export interface INpLinkedActivity {
    header: NpHeader | undefined;
    body: NpBody | undefined;
    error: ErrorDto | undefined;
}

export class NpHeader implements INpHeader {
    transactionStatus: string | undefined;
    audit: NpAudit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: INpHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? NpAudit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): NpHeader {
        data = typeof data === 'object' ? data : {};
        let result = new NpHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): NpHeader {
        const json = this.toJSON();
        let result = new NpHeader();
        result.init(json);
        return result;
    }
}

export interface INpHeader {
    transactionStatus: string | undefined;
    audit: NpAudit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class NpBody implements INpBody {
    arrangementId: string | undefined;
    activityId: string | undefined;
    productId: string | undefined;
    currencyId: string | undefined;
    effectiveDate: string | undefined;
    beneficiaryAccountNo: string | undefined;
    amount: string | undefined;
    channel: string | undefined;
    originatorBVN: string | undefined;
    beneficiaryBVN: string | undefined;
    beneficiaryAccountName: string | undefined;
    originatorAccountNumber: string | undefined;
    narration: string | undefined;
    nameEnquiryRef: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    originatorAccountName: string | undefined;
    channelCode: string | undefined;

    constructor(data?: INpBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.arrangementId = _data["arrangementId"];
            this.activityId = _data["activityId"];
            this.productId = _data["productId"];
            this.currencyId = _data["currencyId"];
            this.effectiveDate = _data["effectiveDate"];
            this.beneficiaryAccountNo = _data["beneficiaryAccountNo"];
            this.amount = _data["amount"];
            this.channel = _data["channel"];
            this.originatorBVN = _data["originatorBVN"];
            this.beneficiaryBVN = _data["beneficiaryBVN"];
            this.beneficiaryAccountName = _data["beneficiaryAccountName"];
            this.originatorAccountNumber = _data["originatorAccountNumber"];
            this.narration = _data["narration"];
            this.nameEnquiryRef = _data["nameEnquiryRef"];
            this.externalBankCode = _data["externalBankCode"];
            this.currency = _data["currency"];
            this.originatorAccountName = _data["originatorAccountName"];
            this.channelCode = _data["channelCode"];
        }
    }

    static fromJS(data: any): NpBody {
        data = typeof data === 'object' ? data : {};
        let result = new NpBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrangementId"] = this.arrangementId;
        data["activityId"] = this.activityId;
        data["productId"] = this.productId;
        data["currencyId"] = this.currencyId;
        data["effectiveDate"] = this.effectiveDate;
        data["beneficiaryAccountNo"] = this.beneficiaryAccountNo;
        data["amount"] = this.amount;
        data["channel"] = this.channel;
        data["originatorBVN"] = this.originatorBVN;
        data["beneficiaryBVN"] = this.beneficiaryBVN;
        data["beneficiaryAccountName"] = this.beneficiaryAccountName;
        data["originatorAccountNumber"] = this.originatorAccountNumber;
        data["narration"] = this.narration;
        data["nameEnquiryRef"] = this.nameEnquiryRef;
        data["externalBankCode"] = this.externalBankCode;
        data["currency"] = this.currency;
        data["originatorAccountName"] = this.originatorAccountName;
        data["channelCode"] = this.channelCode;
        return data; 
    }

    clone(): NpBody {
        const json = this.toJSON();
        let result = new NpBody();
        result.init(json);
        return result;
    }
}

export interface INpBody {
    arrangementId: string | undefined;
    activityId: string | undefined;
    productId: string | undefined;
    currencyId: string | undefined;
    effectiveDate: string | undefined;
    beneficiaryAccountNo: string | undefined;
    amount: string | undefined;
    channel: string | undefined;
    originatorBVN: string | undefined;
    beneficiaryBVN: string | undefined;
    beneficiaryAccountName: string | undefined;
    originatorAccountNumber: string | undefined;
    narration: string | undefined;
    nameEnquiryRef: string | undefined;
    externalBankCode: string | undefined;
    currency: string | undefined;
    originatorAccountName: string | undefined;
    channelCode: string | undefined;
}

export class NpAudit implements INpAudit {
    versionNumber: string | undefined;
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;

    constructor(data?: INpAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionNumber = _data["versionNumber"];
            this.t24_time = _data["T24_time"];
            this.responseParse_time = _data["responseParse_time"];
            this.requestParse_time = _data["requestParse_time"];
        }
    }

    static fromJS(data: any): NpAudit {
        data = typeof data === 'object' ? data : {};
        let result = new NpAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionNumber"] = this.versionNumber;
        data["T24_time"] = this.t24_time;
        data["responseParse_time"] = this.responseParse_time;
        data["requestParse_time"] = this.requestParse_time;
        return data; 
    }

    clone(): NpAudit {
        const json = this.toJSON();
        let result = new NpAudit();
        result.init(json);
        return result;
    }
}

export interface INpAudit {
    versionNumber: string | undefined;
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
}

export class CtRoot implements ICtRoot {
    body: CtBody | undefined;

    constructor(data?: ICtRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? CtBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CtRoot {
        data = typeof data === 'object' ? data : {};
        let result = new CtRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CtRoot {
        const json = this.toJSON();
        let result = new CtRoot();
        result.init(json);
        return result;
    }
}

export interface ICtRoot {
    body: CtBody | undefined;
}

export class CtBody implements ICtBody {
    denominationValues: DenominationValue[] | undefined;
    depositAmount: string | undefined;
    creditAccount: string | undefined;
    narrative: string | undefined;
    documentNo: string | undefined;
    channel: string | undefined;
    currency: string | undefined;

    constructor(data?: ICtBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["denominationValues"])) {
                this.denominationValues = [] as any;
                for (let item of _data["denominationValues"])
                    this.denominationValues.push(DenominationValue.fromJS(item));
            }
            this.depositAmount = _data["depositAmount"];
            this.creditAccount = _data["creditAccount"];
            this.narrative = _data["narrative"];
            this.documentNo = _data["documentNo"];
            this.channel = _data["channel"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): CtBody {
        data = typeof data === 'object' ? data : {};
        let result = new CtBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.denominationValues)) {
            data["denominationValues"] = [];
            for (let item of this.denominationValues)
                data["denominationValues"].push(item.toJSON());
        }
        data["depositAmount"] = this.depositAmount;
        data["creditAccount"] = this.creditAccount;
        data["narrative"] = this.narrative;
        data["documentNo"] = this.documentNo;
        data["channel"] = this.channel;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): CtBody {
        const json = this.toJSON();
        let result = new CtBody();
        result.init(json);
        return result;
    }
}

export interface ICtBody {
    denominationValues: DenominationValue[] | undefined;
    depositAmount: string | undefined;
    creditAccount: string | undefined;
    narrative: string | undefined;
    documentNo: string | undefined;
    channel: string | undefined;
    currency: string | undefined;
}

export class DenominationValue implements IDenominationValue {
    denomination: string | undefined;
    unit: string | undefined;
    units: string | undefined;

    constructor(data?: IDenominationValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.denomination = _data["denomination"];
            this.unit = _data["unit"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): DenominationValue {
        data = typeof data === 'object' ? data : {};
        let result = new DenominationValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denomination"] = this.denomination;
        data["unit"] = this.unit;
        data["units"] = this.units;
        return data; 
    }

    clone(): DenominationValue {
        const json = this.toJSON();
        let result = new DenominationValue();
        result.init(json);
        return result;
    }
}

export interface IDenominationValue {
    denomination: string | undefined;
    unit: string | undefined;
    units: string | undefined;
}

export class ApiResultOfCtRRoot implements IApiResultOfCtRRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: CtRRoot | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfCtRRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? CtRRoot.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfCtRRoot {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfCtRRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfCtRRoot {
        const json = this.toJSON();
        let result = new ApiResultOfCtRRoot();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfCtRRoot {
    hasError: boolean | undefined;
    message: string | undefined;
    result: CtRRoot | undefined;
    totalCount: number | undefined;
}

export class CtRRoot implements ICtRRoot {
    header: CtHeader | undefined;
    body: CtBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: ICtRRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? CtHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? CtBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CtRRoot {
        data = typeof data === 'object' ? data : {};
        let result = new CtRRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CtRRoot {
        const json = this.toJSON();
        let result = new CtRRoot();
        result.init(json);
        return result;
    }
}

export interface ICtRRoot {
    header: CtHeader | undefined;
    body: CtBody | undefined;
    error: ErrorDto | undefined;
}

export class CtHeader implements ICtHeader {
    transactionStatus: string | undefined;
    audit: CtAudit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: ICtHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? CtAudit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CtHeader {
        data = typeof data === 'object' ? data : {};
        let result = new CtHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): CtHeader {
        const json = this.toJSON();
        let result = new CtHeader();
        result.init(json);
        return result;
    }
}

export interface ICtHeader {
    transactionStatus: string | undefined;
    audit: CtAudit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class CtAudit implements ICtAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;

    constructor(data?: ICtAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.t24_time = _data["T24_time"];
            this.responseParse_time = _data["responseParse_time"];
            this.requestParse_time = _data["requestParse_time"];
            this.versionNumber = _data["versionNumber"];
        }
    }

    static fromJS(data: any): CtAudit {
        data = typeof data === 'object' ? data : {};
        let result = new CtAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["T24_time"] = this.t24_time;
        data["responseParse_time"] = this.responseParse_time;
        data["requestParse_time"] = this.requestParse_time;
        data["versionNumber"] = this.versionNumber;
        return data; 
    }

    clone(): CtAudit {
        const json = this.toJSON();
        let result = new CtAudit();
        result.init(json);
        return result;
    }
}

export interface ICtAudit {
    t24_time: number | undefined;
    responseParse_time: number | undefined;
    requestParse_time: number | undefined;
    versionNumber: string | undefined;
}

export class ApiResultOfBankResponseModel implements IApiResultOfBankResponseModel {
    hasError: boolean | undefined;
    message: string | undefined;
    result: BankResponseModel | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfBankResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? BankResponseModel.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfBankResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfBankResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfBankResponseModel {
        const json = this.toJSON();
        let result = new ApiResultOfBankResponseModel();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfBankResponseModel {
    hasError: boolean | undefined;
    message: string | undefined;
    result: BankResponseModel | undefined;
    totalCount: number | undefined;
}

export class BankResponseModel implements IBankResponseModel {
    header: BankResponseModelHeader | undefined;
    body: BankResponseModelBody[] | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IBankResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? BankResponseModelHeader.fromJS(_data["header"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(BankResponseModelBody.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BankResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new BankResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BankResponseModel {
        const json = this.toJSON();
        let result = new BankResponseModel();
        result.init(json);
        return result;
    }
}

export interface IBankResponseModel {
    header: BankResponseModelHeader | undefined;
    body: BankResponseModelBody[] | undefined;
    error: ErrorDto | undefined;
}

export class BankResponseModelHeader implements IBankResponseModelHeader {
    audit: Audit | undefined;
    page_start: number | undefined;
    page_token: string | undefined;
    total_size: number | undefined;
    page_size: number | undefined;
    status: string | undefined;

    constructor(data?: IBankResponseModelHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.page_start = _data["page_start"];
            this.page_token = _data["page_token"];
            this.total_size = _data["total_size"];
            this.page_size = _data["page_size"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BankResponseModelHeader {
        data = typeof data === 'object' ? data : {};
        let result = new BankResponseModelHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["page_start"] = this.page_start;
        data["page_token"] = this.page_token;
        data["total_size"] = this.total_size;
        data["page_size"] = this.page_size;
        data["status"] = this.status;
        return data; 
    }

    clone(): BankResponseModelHeader {
        const json = this.toJSON();
        let result = new BankResponseModelHeader();
        result.init(json);
        return result;
    }
}

export interface IBankResponseModelHeader {
    audit: Audit | undefined;
    page_start: number | undefined;
    page_token: string | undefined;
    total_size: number | undefined;
    page_size: number | undefined;
    status: string | undefined;
}

export class BankResponseModelBody implements IBankResponseModelBody {
    institutionCode: string | undefined;
    institutionName: string | undefined;

    constructor(data?: IBankResponseModelBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.institutionCode = _data["institutionCode"];
            this.institutionName = _data["institutionName"];
        }
    }

    static fromJS(data: any): BankResponseModelBody {
        data = typeof data === 'object' ? data : {};
        let result = new BankResponseModelBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institutionCode"] = this.institutionCode;
        data["institutionName"] = this.institutionName;
        return data; 
    }

    clone(): BankResponseModelBody {
        const json = this.toJSON();
        let result = new BankResponseModelBody();
        result.init(json);
        return result;
    }
}

export interface IBankResponseModelBody {
    institutionCode: string | undefined;
    institutionName: string | undefined;
}

export class CashWithdrawalModel implements ICashWithdrawalModel {
    body: CashWithdrawalModelBody | undefined;

    constructor(data?: ICashWithdrawalModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? CashWithdrawalModelBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashWithdrawalModel {
        data = typeof data === 'object' ? data : {};
        let result = new CashWithdrawalModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CashWithdrawalModel {
        const json = this.toJSON();
        let result = new CashWithdrawalModel();
        result.init(json);
        return result;
    }
}

export interface ICashWithdrawalModel {
    body: CashWithdrawalModelBody | undefined;
}

export class CashWithdrawalModelBody implements ICashWithdrawalModelBody {
    denominationValues: DenominationValue[] | undefined;
    localAmount: string | undefined;
    debitAccount: string | undefined;
    narrative: string | undefined;
    documentNo: string | undefined;
    channel: string | undefined;
    currency: string | undefined;

    constructor(data?: ICashWithdrawalModelBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["denominationValues"])) {
                this.denominationValues = [] as any;
                for (let item of _data["denominationValues"])
                    this.denominationValues.push(DenominationValue.fromJS(item));
            }
            this.localAmount = _data["localAmount"];
            this.debitAccount = _data["debitAccount"];
            this.narrative = _data["narrative"];
            this.documentNo = _data["documentNo"];
            this.channel = _data["channel"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): CashWithdrawalModelBody {
        data = typeof data === 'object' ? data : {};
        let result = new CashWithdrawalModelBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.denominationValues)) {
            data["denominationValues"] = [];
            for (let item of this.denominationValues)
                data["denominationValues"].push(item.toJSON());
        }
        data["localAmount"] = this.localAmount;
        data["debitAccount"] = this.debitAccount;
        data["narrative"] = this.narrative;
        data["documentNo"] = this.documentNo;
        data["channel"] = this.channel;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): CashWithdrawalModelBody {
        const json = this.toJSON();
        let result = new CashWithdrawalModelBody();
        result.init(json);
        return result;
    }
}

export interface ICashWithdrawalModelBody {
    denominationValues: DenominationValue[] | undefined;
    localAmount: string | undefined;
    debitAccount: string | undefined;
    narrative: string | undefined;
    documentNo: string | undefined;
    channel: string | undefined;
    currency: string | undefined;
}

export class ApiResultOfCashWithdrawalResponse implements IApiResultOfCashWithdrawalResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: CashWithdrawalResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfCashWithdrawalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? CashWithdrawalResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfCashWithdrawalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfCashWithdrawalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfCashWithdrawalResponse {
        const json = this.toJSON();
        let result = new ApiResultOfCashWithdrawalResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfCashWithdrawalResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: CashWithdrawalResponse | undefined;
    totalCount: number | undefined;
}

export class CashWithdrawalResponse implements ICashWithdrawalResponse {
    header: CashWithdrawalResponseHeader | undefined;
    body: CashWithdrawalResponseBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: ICashWithdrawalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? CashWithdrawalResponseHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? CashWithdrawalResponseBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashWithdrawalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CashWithdrawalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CashWithdrawalResponse {
        const json = this.toJSON();
        let result = new CashWithdrawalResponse();
        result.init(json);
        return result;
    }
}

export interface ICashWithdrawalResponse {
    header: CashWithdrawalResponseHeader | undefined;
    body: CashWithdrawalResponseBody | undefined;
    error: ErrorDto | undefined;
}

export class CashWithdrawalResponseHeader implements ICashWithdrawalResponseHeader {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;

    constructor(data?: ICashWithdrawalResponseHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CashWithdrawalResponseHeader {
        data = typeof data === 'object' ? data : {};
        let result = new CashWithdrawalResponseHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): CashWithdrawalResponseHeader {
        const json = this.toJSON();
        let result = new CashWithdrawalResponseHeader();
        result.init(json);
        return result;
    }
}

export interface ICashWithdrawalResponseHeader {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;
}

export class CashWithdrawalResponseBody implements ICashWithdrawalResponseBody {
    debitAccount: string | undefined;
    narrative: string | undefined;
    channel: string | undefined;
    teller: string | undefined;
    dr_CrMarker: string | undefined;
    valueDate: string | undefined;
    internalAccount: string | undefined;
    documentNo: string | undefined;
    cashPaidtoCust: string | undefined;
    newCustBal: string | undefined;
    currency: string | undefined;
    localAmount: string | undefined;
    customer: string | undefined;

    constructor(data?: ICashWithdrawalResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debitAccount = _data["debitAccount"];
            this.narrative = _data["narrative"];
            this.channel = _data["channel"];
            this.teller = _data["teller"];
            this.dr_CrMarker = _data["dr/CrMarker"];
            this.valueDate = _data["valueDate"];
            this.internalAccount = _data["internalAccount"];
            this.documentNo = _data["documentNo"];
            this.cashPaidtoCust = _data["cashPaidtoCust"];
            this.newCustBal = _data["newCustBal"];
            this.currency = _data["currency"];
            this.localAmount = _data["localAmount"];
            this.customer = _data["customer"];
        }
    }

    static fromJS(data: any): CashWithdrawalResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new CashWithdrawalResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debitAccount"] = this.debitAccount;
        data["narrative"] = this.narrative;
        data["channel"] = this.channel;
        data["teller"] = this.teller;
        data["dr/CrMarker"] = this.dr_CrMarker;
        data["valueDate"] = this.valueDate;
        data["internalAccount"] = this.internalAccount;
        data["documentNo"] = this.documentNo;
        data["cashPaidtoCust"] = this.cashPaidtoCust;
        data["newCustBal"] = this.newCustBal;
        data["currency"] = this.currency;
        data["localAmount"] = this.localAmount;
        data["customer"] = this.customer;
        return data; 
    }

    clone(): CashWithdrawalResponseBody {
        const json = this.toJSON();
        let result = new CashWithdrawalResponseBody();
        result.init(json);
        return result;
    }
}

export interface ICashWithdrawalResponseBody {
    debitAccount: string | undefined;
    narrative: string | undefined;
    channel: string | undefined;
    teller: string | undefined;
    dr_CrMarker: string | undefined;
    valueDate: string | undefined;
    internalAccount: string | undefined;
    documentNo: string | undefined;
    cashPaidtoCust: string | undefined;
    newCustBal: string | undefined;
    currency: string | undefined;
    localAmount: string | undefined;
    customer: string | undefined;
}

export class PostChequePayload implements IPostChequePayload {
    body: PostChequePayloadBody | undefined;

    constructor(data?: IPostChequePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? PostChequePayloadBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostChequePayload {
        data = typeof data === 'object' ? data : {};
        let result = new PostChequePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PostChequePayload {
        const json = this.toJSON();
        let result = new PostChequePayload();
        result.init(json);
        return result;
    }
}

export interface IPostChequePayload {
    body: PostChequePayloadBody | undefined;
}

export class PostChequePayloadBody implements IPostChequePayloadBody {
    chequeNo: string | undefined;
    debitAccount: string | undefined;
    amount: string | undefined;
    currency: string | undefined;
    narration: string | undefined;

    constructor(data?: IPostChequePayloadBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chequeNo = _data["chequeNo"];
            this.debitAccount = _data["debitAccount"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.narration = _data["narration"];
        }
    }

    static fromJS(data: any): PostChequePayloadBody {
        data = typeof data === 'object' ? data : {};
        let result = new PostChequePayloadBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chequeNo"] = this.chequeNo;
        data["debitAccount"] = this.debitAccount;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["narration"] = this.narration;
        return data; 
    }

    clone(): PostChequePayloadBody {
        const json = this.toJSON();
        let result = new PostChequePayloadBody();
        result.init(json);
        return result;
    }
}

export interface IPostChequePayloadBody {
    chequeNo: string | undefined;
    debitAccount: string | undefined;
    amount: string | undefined;
    currency: string | undefined;
    narration: string | undefined;
}

export class ApiResultOfPostChequeResponse implements IApiResultOfPostChequeResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: PostChequeResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfPostChequeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? PostChequeResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfPostChequeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPostChequeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfPostChequeResponse {
        const json = this.toJSON();
        let result = new ApiResultOfPostChequeResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfPostChequeResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: PostChequeResponse | undefined;
    totalCount: number | undefined;
}

export class PostChequeResponse implements IPostChequeResponse {
    header: PostChequeResponseHeader | undefined;
    body: PostChequeResponseBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IPostChequeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? PostChequeResponseHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? PostChequeResponseBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostChequeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PostChequeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PostChequeResponse {
        const json = this.toJSON();
        let result = new PostChequeResponse();
        result.init(json);
        return result;
    }
}

export interface IPostChequeResponse {
    header: PostChequeResponseHeader | undefined;
    body: PostChequeResponseBody | undefined;
    error: ErrorDto | undefined;
}

export class PostChequeResponseHeader implements IPostChequeResponseHeader {
    id: string | undefined;
    status: string | undefined;
    transactionStatus: string | undefined;
    uniqueIdentifier: string | undefined;
    audit: Audit | undefined;

    constructor(data?: IPostChequeResponseHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.transactionStatus = _data["transactionStatus"];
            this.uniqueIdentifier = _data["uniqueIdentifier"];
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostChequeResponseHeader {
        data = typeof data === 'object' ? data : {};
        let result = new PostChequeResponseHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["transactionStatus"] = this.transactionStatus;
        data["uniqueIdentifier"] = this.uniqueIdentifier;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PostChequeResponseHeader {
        const json = this.toJSON();
        let result = new PostChequeResponseHeader();
        result.init(json);
        return result;
    }
}

export interface IPostChequeResponseHeader {
    id: string | undefined;
    status: string | undefined;
    transactionStatus: string | undefined;
    uniqueIdentifier: string | undefined;
    audit: Audit | undefined;
}

export class PostChequeResponseBody implements IPostChequeResponseBody {
    debitAccount: string | undefined;
    amount: string | undefined;
    debitValueDate: string | undefined;
    chequeNo: string | undefined;
    narration: string | undefined;
    creditValueDate: string | undefined;
    amountDebited: string | undefined;
    amountCredited: string | undefined;
    deliveryReference: string | undefined;
    override: string | undefined;
    currency: string | undefined;

    constructor(data?: IPostChequeResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debitAccount = _data["debitAccount"];
            this.amount = _data["amount"];
            this.debitValueDate = _data["debitValueDate"];
            this.chequeNo = _data["chequeNo"];
            this.narration = _data["narration"];
            this.creditValueDate = _data["creditValueDate"];
            this.amountDebited = _data["amountDebited"];
            this.amountCredited = _data["amountCredited"];
            this.deliveryReference = _data["deliveryReference"];
            this.override = _data["override"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): PostChequeResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new PostChequeResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debitAccount"] = this.debitAccount;
        data["amount"] = this.amount;
        data["debitValueDate"] = this.debitValueDate;
        data["chequeNo"] = this.chequeNo;
        data["narration"] = this.narration;
        data["creditValueDate"] = this.creditValueDate;
        data["amountDebited"] = this.amountDebited;
        data["amountCredited"] = this.amountCredited;
        data["deliveryReference"] = this.deliveryReference;
        data["override"] = this.override;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): PostChequeResponseBody {
        const json = this.toJSON();
        let result = new PostChequeResponseBody();
        result.init(json);
        return result;
    }
}

export interface IPostChequeResponseBody {
    debitAccount: string | undefined;
    amount: string | undefined;
    debitValueDate: string | undefined;
    chequeNo: string | undefined;
    narration: string | undefined;
    creditValueDate: string | undefined;
    amountDebited: string | undefined;
    amountCredited: string | undefined;
    deliveryReference: string | undefined;
    override: string | undefined;
    currency: string | undefined;
}

export class ApiResultOfAuthorizeChequeResponse implements IApiResultOfAuthorizeChequeResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: AuthorizeChequeResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfAuthorizeChequeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? AuthorizeChequeResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfAuthorizeChequeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfAuthorizeChequeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfAuthorizeChequeResponse {
        const json = this.toJSON();
        let result = new ApiResultOfAuthorizeChequeResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfAuthorizeChequeResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: AuthorizeChequeResponse | undefined;
    totalCount: number | undefined;
}

export class AuthorizeChequeResponse implements IAuthorizeChequeResponse {
    header: PostChequeResponseHeader | undefined;
    body: PostChequeResponseBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IAuthorizeChequeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? PostChequeResponseHeader.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? PostChequeResponseBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthorizeChequeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeChequeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AuthorizeChequeResponse {
        const json = this.toJSON();
        let result = new AuthorizeChequeResponse();
        result.init(json);
        return result;
    }
}

export interface IAuthorizeChequeResponse {
    header: PostChequeResponseHeader | undefined;
    body: PostChequeResponseBody | undefined;
    error: ErrorDto | undefined;
}

export class UpdateAccountInfoPayload implements IUpdateAccountInfoPayload {
    body: UpdateAccountInfoPayloadBody | undefined;

    constructor(data?: IUpdateAccountInfoPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? UpdateAccountInfoPayloadBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAccountInfoPayload {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountInfoPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpdateAccountInfoPayload {
        const json = this.toJSON();
        let result = new UpdateAccountInfoPayload();
        result.init(json);
        return result;
    }
}

export interface IUpdateAccountInfoPayload {
    body: UpdateAccountInfoPayloadBody | undefined;
}

export class UpdateAccountInfoPayloadBody implements IUpdateAccountInfoPayloadBody {
    accountNo: string | undefined;
    category: string | undefined;
    accountName: string | undefined;
    currency: string | undefined;

    constructor(data?: IUpdateAccountInfoPayloadBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountNo = _data["accountNo"];
            this.category = _data["category"];
            this.accountName = _data["accountName"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): UpdateAccountInfoPayloadBody {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountInfoPayloadBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNo"] = this.accountNo;
        data["category"] = this.category;
        data["accountName"] = this.accountName;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): UpdateAccountInfoPayloadBody {
        const json = this.toJSON();
        let result = new UpdateAccountInfoPayloadBody();
        result.init(json);
        return result;
    }
}

export interface IUpdateAccountInfoPayloadBody {
    accountNo: string | undefined;
    category: string | undefined;
    accountName: string | undefined;
    currency: string | undefined;
}

export class ApiResultOfUpdateAccountInfoResponse implements IApiResultOfUpdateAccountInfoResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: UpdateAccountInfoResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfUpdateAccountInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? UpdateAccountInfoResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfUpdateAccountInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUpdateAccountInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfUpdateAccountInfoResponse {
        const json = this.toJSON();
        let result = new ApiResultOfUpdateAccountInfoResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfUpdateAccountInfoResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: UpdateAccountInfoResponse | undefined;
    totalCount: number | undefined;
}

export class UpdateAccountInfoResponse implements IUpdateAccountInfoResponse {
    header: Header | undefined;
    body: UpdateAccountInfoResponseBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IUpdateAccountInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? Header.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? UpdateAccountInfoResponseBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAccountInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpdateAccountInfoResponse {
        const json = this.toJSON();
        let result = new UpdateAccountInfoResponse();
        result.init(json);
        return result;
    }
}

export interface IUpdateAccountInfoResponse {
    header: Header | undefined;
    body: UpdateAccountInfoResponseBody | undefined;
    error: ErrorDto | undefined;
}

export class UpdateAccountInfoResponseBody implements IUpdateAccountInfoResponseBody {
    openingDate: string | undefined;
    customerNo: string | undefined;
    accountNo: string | undefined;
    category: string | undefined;
    accountName: string | undefined;
    currency: string | undefined;

    constructor(data?: IUpdateAccountInfoResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openingDate = _data["openingDate"];
            this.customerNo = _data["customerNo"];
            this.accountNo = _data["accountNo"];
            this.category = _data["category"];
            this.accountName = _data["accountName"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): UpdateAccountInfoResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountInfoResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openingDate"] = this.openingDate;
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["category"] = this.category;
        data["accountName"] = this.accountName;
        data["currency"] = this.currency;
        return data; 
    }

    clone(): UpdateAccountInfoResponseBody {
        const json = this.toJSON();
        let result = new UpdateAccountInfoResponseBody();
        result.init(json);
        return result;
    }
}

export interface IUpdateAccountInfoResponseBody {
    openingDate: string | undefined;
    customerNo: string | undefined;
    accountNo: string | undefined;
    category: string | undefined;
    accountName: string | undefined;
    currency: string | undefined;
}

export class FreezeAccountPayload implements IFreezeAccountPayload {
    body: FreezeAccountPayloadBody | undefined;

    constructor(data?: IFreezeAccountPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"] ? FreezeAccountPayloadBody.fromJS(_data["body"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FreezeAccountPayload {
        data = typeof data === 'object' ? data : {};
        let result = new FreezeAccountPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FreezeAccountPayload {
        const json = this.toJSON();
        let result = new FreezeAccountPayload();
        result.init(json);
        return result;
    }
}

export interface IFreezeAccountPayload {
    body: FreezeAccountPayloadBody | undefined;
}

export class FreezeAccountPayloadBody implements IFreezeAccountPayloadBody {
    accountNo: string | undefined;
    freezeAccount: string | undefined;
    shortName: string | undefined;

    constructor(data?: IFreezeAccountPayloadBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountNo = _data["accountNo"];
            this.freezeAccount = _data["freezeAccount"];
            this.shortName = _data["shortName"];
        }
    }

    static fromJS(data: any): FreezeAccountPayloadBody {
        data = typeof data === 'object' ? data : {};
        let result = new FreezeAccountPayloadBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNo"] = this.accountNo;
        data["freezeAccount"] = this.freezeAccount;
        data["shortName"] = this.shortName;
        return data; 
    }

    clone(): FreezeAccountPayloadBody {
        const json = this.toJSON();
        let result = new FreezeAccountPayloadBody();
        result.init(json);
        return result;
    }
}

export interface IFreezeAccountPayloadBody {
    accountNo: string | undefined;
    freezeAccount: string | undefined;
    shortName: string | undefined;
}

export class ApiResultOfFreezeAccountResponse implements IApiResultOfFreezeAccountResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: FreezeAccountResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfFreezeAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? FreezeAccountResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfFreezeAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfFreezeAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfFreezeAccountResponse {
        const json = this.toJSON();
        let result = new ApiResultOfFreezeAccountResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfFreezeAccountResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: FreezeAccountResponse | undefined;
    totalCount: number | undefined;
}

export class FreezeAccountResponse implements IFreezeAccountResponse {
    header: Header | undefined;
    body: FreezeAccountPayloadBody | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IFreezeAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? Header.fromJS(_data["header"]) : <any>undefined;
            this.body = _data["body"] ? FreezeAccountPayloadBody.fromJS(_data["body"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FreezeAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FreezeAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FreezeAccountResponse {
        const json = this.toJSON();
        let result = new FreezeAccountResponse();
        result.init(json);
        return result;
    }
}

export interface IFreezeAccountResponse {
    header: Header | undefined;
    body: FreezeAccountPayloadBody | undefined;
    error: ErrorDto | undefined;
}

export class GetAccountStatementPayload implements IGetAccountStatementPayload {
    accountNo: string | undefined;
    startdate: Date | undefined;
    enddate: Date | undefined;
    sendStatementToEmail: boolean | undefined;

    constructor(data?: IGetAccountStatementPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountNo = _data["accountNo"];
            this.startdate = _data["startdate"] ? new Date(_data["startdate"].toString()) : <any>undefined;
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.sendStatementToEmail = _data["SendStatementToEmail"];
        }
    }

    static fromJS(data: any): GetAccountStatementPayload {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountStatementPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNo"] = this.accountNo;
        data["startdate"] = this.startdate ? this.startdate.toISOString() : <any>undefined;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["SendStatementToEmail"] = this.sendStatementToEmail;
        return data; 
    }

    clone(): GetAccountStatementPayload {
        const json = this.toJSON();
        let result = new GetAccountStatementPayload();
        result.init(json);
        return result;
    }
}

export interface IGetAccountStatementPayload {
    accountNo: string | undefined;
    startdate: Date | undefined;
    enddate: Date | undefined;
    sendStatementToEmail: boolean | undefined;
}

export class ApiResultOfGetAccountStatementResponse implements IApiResultOfGetAccountStatementResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAccountStatementResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetAccountStatementResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetAccountStatementResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetAccountStatementResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetAccountStatementResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetAccountStatementResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetAccountStatementResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetAccountStatementResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAccountStatementResponse | undefined;
    totalCount: number | undefined;
}

export class GetAccountStatementResponse implements IGetAccountStatementResponse {
    header: GetAccountStatementHeader | undefined;
    body: GetAccountStatementResponseBody[] | undefined;
    error: ErrorDto | undefined;

    constructor(data?: IGetAccountStatementResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? GetAccountStatementHeader.fromJS(_data["header"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetAccountStatementResponseBody.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountStatementResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountStatementResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetAccountStatementResponse {
        const json = this.toJSON();
        let result = new GetAccountStatementResponse();
        result.init(json);
        return result;
    }
}

export interface IGetAccountStatementResponse {
    header: GetAccountStatementHeader | undefined;
    body: GetAccountStatementResponseBody[] | undefined;
    error: ErrorDto | undefined;
}

export class GetAccountStatementHeader implements IGetAccountStatementHeader {
    audit: Audit | undefined;
    status: string | undefined;
    page_size: number | undefined;
    page_start: number | undefined;
    total_size: number | undefined;

    constructor(data?: IGetAccountStatementHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.status = _data["status"];
            this.page_size = _data["page_size"];
            this.page_start = _data["page_start"];
            this.total_size = _data["total_size"];
        }
    }

    static fromJS(data: any): GetAccountStatementHeader {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountStatementHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["page_size"] = this.page_size;
        data["page_start"] = this.page_start;
        data["total_size"] = this.total_size;
        return data; 
    }

    clone(): GetAccountStatementHeader {
        const json = this.toJSON();
        let result = new GetAccountStatementHeader();
        result.init(json);
        return result;
    }
}

export interface IGetAccountStatementHeader {
    audit: Audit | undefined;
    status: string | undefined;
    page_size: number | undefined;
    page_start: number | undefined;
    total_size: number | undefined;
}

export class GetAccountStatementResponseBody implements IGetAccountStatementResponseBody {
    transactionDate: string | undefined;
    transactionRef: string | undefined;
    narration: string | undefined;
    debitAmt: string | undefined;
    creditAmt: string | undefined;

    constructor(data?: IGetAccountStatementResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionDate = _data["transactionDate"];
            this.transactionRef = _data["transactionRef"];
            this.narration = _data["narration"];
            this.debitAmt = _data["debitAmt"];
            this.creditAmt = _data["creditAmt"];
        }
    }

    static fromJS(data: any): GetAccountStatementResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountStatementResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionDate"] = this.transactionDate;
        data["transactionRef"] = this.transactionRef;
        data["narration"] = this.narration;
        data["debitAmt"] = this.debitAmt;
        data["creditAmt"] = this.creditAmt;
        return data; 
    }

    clone(): GetAccountStatementResponseBody {
        const json = this.toJSON();
        let result = new GetAccountStatementResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetAccountStatementResponseBody {
    transactionDate: string | undefined;
    transactionRef: string | undefined;
    narration: string | undefined;
    debitAmt: string | undefined;
    creditAmt: string | undefined;
}

export class ApiResultOfGetAcctCategoriesResponse implements IApiResultOfGetAcctCategoriesResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAcctCategoriesResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetAcctCategoriesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetAcctCategoriesResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetAcctCategoriesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetAcctCategoriesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetAcctCategoriesResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetAcctCategoriesResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetAcctCategoriesResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetAcctCategoriesResponse | undefined;
    totalCount: number | undefined;
}

export class GetAcctCategoriesResponse implements IGetAcctCategoriesResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetAcctCategoriesResponseBody[] | undefined;

    constructor(data?: IGetAcctCategoriesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? FetchDataHeader.fromJS(_data["header"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetAcctCategoriesResponseBody.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAcctCategoriesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAcctCategoriesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAcctCategoriesResponse {
        const json = this.toJSON();
        let result = new GetAcctCategoriesResponse();
        result.init(json);
        return result;
    }
}

export interface IGetAcctCategoriesResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetAcctCategoriesResponseBody[] | undefined;
}

export class FetchDataHeader implements IFetchDataHeader {
    audit: Audit | undefined;
    status: string | undefined;
    page_size: number | undefined;
    page_start: number | undefined;
    total_size: number | undefined;
    page_token: string | undefined;

    constructor(data?: IFetchDataHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.status = _data["status"];
            this.page_size = _data["page_size"];
            this.page_start = _data["page_start"];
            this.total_size = _data["total_size"];
            this.page_token = _data["page_token"];
        }
    }

    static fromJS(data: any): FetchDataHeader {
        data = typeof data === 'object' ? data : {};
        let result = new FetchDataHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["page_size"] = this.page_size;
        data["page_start"] = this.page_start;
        data["total_size"] = this.total_size;
        data["page_token"] = this.page_token;
        return data; 
    }

    clone(): FetchDataHeader {
        const json = this.toJSON();
        let result = new FetchDataHeader();
        result.init(json);
        return result;
    }
}

export interface IFetchDataHeader {
    audit: Audit | undefined;
    status: string | undefined;
    page_size: number | undefined;
    page_start: number | undefined;
    total_size: number | undefined;
    page_token: string | undefined;
}

export class GetAcctCategoriesResponseBody implements IGetAcctCategoriesResponseBody {
    categoryId: string | undefined;
    displayName: string | undefined;
    categoryName: string | undefined;
    productId: string | undefined;

    constructor(data?: IGetAcctCategoriesResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.displayName = _data["displayName"];
            this.categoryName = _data["categoryName"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): GetAcctCategoriesResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetAcctCategoriesResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["displayName"] = this.displayName;
        data["categoryName"] = this.categoryName;
        data["productId"] = this.productId;
        return data; 
    }

    clone(): GetAcctCategoriesResponseBody {
        const json = this.toJSON();
        let result = new GetAcctCategoriesResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetAcctCategoriesResponseBody {
    categoryId: string | undefined;
    displayName: string | undefined;
    categoryName: string | undefined;
    productId: string | undefined;
}

export class ApiResultOfGetSectorListResponse implements IApiResultOfGetSectorListResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetSectorListResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetSectorListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetSectorListResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetSectorListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetSectorListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetSectorListResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetSectorListResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetSectorListResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetSectorListResponse | undefined;
    totalCount: number | undefined;
}

export class GetSectorListResponse implements IGetSectorListResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetSectorListResponseBody[] | undefined;

    constructor(data?: IGetSectorListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? FetchDataHeader.fromJS(_data["header"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetSectorListResponseBody.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSectorListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetSectorListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetSectorListResponse {
        const json = this.toJSON();
        let result = new GetSectorListResponse();
        result.init(json);
        return result;
    }
}

export interface IGetSectorListResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetSectorListResponseBody[] | undefined;
}

export class GetSectorListResponseBody implements IGetSectorListResponseBody {
    sectorId: string | undefined;
    sectorName: string | undefined;

    constructor(data?: IGetSectorListResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.sectorName = _data["sectorName"];
        }
    }

    static fromJS(data: any): GetSectorListResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetSectorListResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["sectorName"] = this.sectorName;
        return data; 
    }

    clone(): GetSectorListResponseBody {
        const json = this.toJSON();
        let result = new GetSectorListResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetSectorListResponseBody {
    sectorId: string | undefined;
    sectorName: string | undefined;
}

export class ApiResultOfGetProductListResponse implements IApiResultOfGetProductListResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetProductListResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetProductListResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetProductListResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetProductListResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetProductListResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetProductListResponse | undefined;
    totalCount: number | undefined;
}

export class GetProductListResponse implements IGetProductListResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetProductListResponseBody[] | undefined;

    constructor(data?: IGetProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? FetchDataHeader.fromJS(_data["header"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetProductListResponseBody.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetProductListResponse {
        const json = this.toJSON();
        let result = new GetProductListResponse();
        result.init(json);
        return result;
    }
}

export interface IGetProductListResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetProductListResponseBody[] | undefined;
}

export class GetProductListResponseBody implements IGetProductListResponseBody {
    product: string | undefined;
    description: string | undefined;
    group: string | undefined;

    constructor(data?: IGetProductListResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"];
            this.description = _data["description"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): GetProductListResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductListResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product;
        data["description"] = this.description;
        data["group"] = this.group;
        return data; 
    }

    clone(): GetProductListResponseBody {
        const json = this.toJSON();
        let result = new GetProductListResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetProductListResponseBody {
    product: string | undefined;
    description: string | undefined;
    group: string | undefined;
}

export class ApiResultOfGetIndustryListResponse implements IApiResultOfGetIndustryListResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetIndustryListResponse | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfGetIndustryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? GetIndustryListResponse.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfGetIndustryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGetIndustryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfGetIndustryListResponse {
        const json = this.toJSON();
        let result = new ApiResultOfGetIndustryListResponse();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfGetIndustryListResponse {
    hasError: boolean | undefined;
    message: string | undefined;
    result: GetIndustryListResponse | undefined;
    totalCount: number | undefined;
}

export class GetIndustryListResponse implements IGetIndustryListResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetIndustryListResponseBody[] | undefined;

    constructor(data?: IGetIndustryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? FetchDataHeader.fromJS(_data["header"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            if (Array.isArray(_data["body"])) {
                this.body = [] as any;
                for (let item of _data["body"])
                    this.body.push(GetIndustryListResponseBody.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIndustryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetIndustryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        if (Array.isArray(this.body)) {
            data["body"] = [];
            for (let item of this.body)
                data["body"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetIndustryListResponse {
        const json = this.toJSON();
        let result = new GetIndustryListResponse();
        result.init(json);
        return result;
    }
}

export interface IGetIndustryListResponse {
    header: FetchDataHeader | undefined;
    error: ErrorDto | undefined;
    body: GetIndustryListResponseBody[] | undefined;
}

export class GetIndustryListResponseBody implements IGetIndustryListResponseBody {
    industryId: string | undefined;
    displayName: string | undefined;

    constructor(data?: IGetIndustryListResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.industryId = _data["industryId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): GetIndustryListResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetIndustryListResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["industryId"] = this.industryId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): GetIndustryListResponseBody {
        const json = this.toJSON();
        let result = new GetIndustryListResponseBody();
        result.init(json);
        return result;
    }
}

export interface IGetIndustryListResponseBody {
    industryId: string | undefined;
    displayName: string | undefined;
}

export class CreateCustomerModelBody implements ICreateCustomerModelBody {
    customer: Customer[] | undefined;
    title: string | undefined;
    familyName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    gender: string | undefined;
    maritalStatus: string | undefined;
    accountOfficer: string | undefined;
    sector: string | undefined;
    industry: string | undefined;
    target: string | undefined;
    nationality: string | undefined;
    residence: string | undefined;
    customerType: string | undefined;
    segment: string | undefined;
    customerStatus: string | undefined;
    dateOfBirth: string | undefined;
    language: string | undefined;
    socialHandle: string | undefined;
    phoneNumber: string | undefined;
    businessType: string | undefined;
    customerTierType: string | undefined;
    email: string | undefined;
    currencyId: string | undefined;
    productId: string | undefined;

    constructor(data?: ICreateCustomerModelBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Customer"])) {
                this.customer = [] as any;
                for (let item of _data["Customer"])
                    this.customer.push(Customer.fromJS(item));
            }
            this.title = _data["title"];
            this.familyName = _data["familyName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.maritalStatus = _data["maritalStatus"];
            this.accountOfficer = _data["accountOfficer"];
            this.sector = _data["sector"];
            this.industry = _data["industry"];
            this.target = _data["target"];
            this.nationality = _data["nationality"];
            this.residence = _data["residence"];
            this.customerType = _data["customerType"];
            this.segment = _data["segment"];
            this.customerStatus = _data["customerStatus"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.language = _data["language"];
            this.socialHandle = _data["socialHandle"];
            this.phoneNumber = _data["phoneNumber"];
            this.businessType = _data["businessType"];
            this.customerTierType = _data["customerTierType"];
            this.email = _data["email"];
            this.currencyId = _data["currencyId"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateCustomerModelBody {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerModelBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customer)) {
            data["Customer"] = [];
            for (let item of this.customer)
                data["Customer"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["familyName"] = this.familyName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["maritalStatus"] = this.maritalStatus;
        data["accountOfficer"] = this.accountOfficer;
        data["sector"] = this.sector;
        data["industry"] = this.industry;
        data["target"] = this.target;
        data["nationality"] = this.nationality;
        data["residence"] = this.residence;
        data["customerType"] = this.customerType;
        data["segment"] = this.segment;
        data["customerStatus"] = this.customerStatus;
        data["dateOfBirth"] = this.dateOfBirth;
        data["language"] = this.language;
        data["socialHandle"] = this.socialHandle;
        data["phoneNumber"] = this.phoneNumber;
        data["businessType"] = this.businessType;
        data["customerTierType"] = this.customerTierType;
        data["email"] = this.email;
        data["currencyId"] = this.currencyId;
        data["productId"] = this.productId;
        return data; 
    }

    clone(): CreateCustomerModelBody {
        const json = this.toJSON();
        let result = new CreateCustomerModelBody();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerModelBody {
    customer: Customer[] | undefined;
    title: string | undefined;
    familyName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    gender: string | undefined;
    maritalStatus: string | undefined;
    accountOfficer: string | undefined;
    sector: string | undefined;
    industry: string | undefined;
    target: string | undefined;
    nationality: string | undefined;
    residence: string | undefined;
    customerType: string | undefined;
    segment: string | undefined;
    customerStatus: string | undefined;
    dateOfBirth: string | undefined;
    language: string | undefined;
    socialHandle: string | undefined;
    phoneNumber: string | undefined;
    businessType: string | undefined;
    customerTierType: string | undefined;
    email: string | undefined;
    currencyId: string | undefined;
    productId: string | undefined;
}

export class Customer implements ICustomer {
    bank: Bank[] | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Bank"])) {
                this.bank = [] as any;
                for (let item of _data["Bank"])
                    this.bank.push(Bank.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bank)) {
            data["Bank"] = [];
            for (let item of this.bank)
                data["Bank"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Customer {
        const json = this.toJSON();
        let result = new Customer();
        result.init(json);
        return result;
    }
}

export interface ICustomer {
    bank: Bank[] | undefined;
}

export class Bank implements IBank {
    bvn: string | undefined;

    constructor(data?: IBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bvn = _data["bvn"];
        }
    }

    static fromJS(data: any): Bank {
        data = typeof data === 'object' ? data : {};
        let result = new Bank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bvn"] = this.bvn;
        return data; 
    }

    clone(): Bank {
        const json = this.toJSON();
        let result = new Bank();
        result.init(json);
        return result;
    }
}

export interface IBank {
    bvn: string | undefined;
}

export class ApiResultOfHeader2 implements IApiResultOfHeader2 {
    hasError: boolean | undefined;
    message: string | undefined;
    result: Header2 | undefined;
    totalCount: number | undefined;

    constructor(data?: IApiResultOfHeader2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["HasError"];
            this.message = _data["Message"];
            this.result = _data["Result"] ? Header2.fromJS(_data["Result"]) : <any>undefined;
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ApiResultOfHeader2 {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfHeader2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasError"] = this.hasError;
        data["Message"] = this.message;
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["TotalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApiResultOfHeader2 {
        const json = this.toJSON();
        let result = new ApiResultOfHeader2();
        result.init(json);
        return result;
    }
}

export interface IApiResultOfHeader2 {
    hasError: boolean | undefined;
    message: string | undefined;
    result: Header2 | undefined;
    totalCount: number | undefined;
}

export class Header2 implements IHeader2 {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;
    override: Override | undefined;
    error: ErrorDto | undefined;
    accountNo: string | undefined;
    accountName: string | undefined;
    accountType: string | undefined;

    constructor(data?: IHeader2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatus = _data["transactionStatus"];
            this.audit = _data["audit"] ? Audit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.status = _data["status"];
            this.override = _data["override"] ? Override.fromJS(_data["override"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            this.accountNo = _data["accountNo"];
            this.accountName = _data["accountName"];
            this.accountType = _data["accountType"];
        }
    }

    static fromJS(data: any): Header2 {
        data = typeof data === 'object' ? data : {};
        let result = new Header2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatus"] = this.transactionStatus;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["status"] = this.status;
        data["override"] = this.override ? this.override.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["accountNo"] = this.accountNo;
        data["accountName"] = this.accountName;
        data["accountType"] = this.accountType;
        return data; 
    }

    clone(): Header2 {
        const json = this.toJSON();
        let result = new Header2();
        result.init(json);
        return result;
    }
}

export interface IHeader2 {
    transactionStatus: string | undefined;
    audit: Audit | undefined;
    id: string | undefined;
    status: string | undefined;
    override: Override | undefined;
    error: ErrorDto | undefined;
    accountNo: string | undefined;
    accountName: string | undefined;
    accountType: string | undefined;
}

export class Override implements IOverride {
    overrideDetails: OverrideDetail[] | undefined;

    constructor(data?: IOverride) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["overrideDetails"])) {
                this.overrideDetails = [] as any;
                for (let item of _data["overrideDetails"])
                    this.overrideDetails.push(OverrideDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Override {
        data = typeof data === 'object' ? data : {};
        let result = new Override();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.overrideDetails)) {
            data["overrideDetails"] = [];
            for (let item of this.overrideDetails)
                data["overrideDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Override {
        const json = this.toJSON();
        let result = new Override();
        result.init(json);
        return result;
    }
}

export interface IOverride {
    overrideDetails: OverrideDetail[] | undefined;
}

export class OverrideDetail implements IOverrideDetail {
    id: string | undefined;
    description: string | undefined;
    code: string | undefined;
    responseCode: string | undefined;

    constructor(data?: IOverrideDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.code = _data["code"];
            this.responseCode = _data["responseCode"];
        }
    }

    static fromJS(data: any): OverrideDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OverrideDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["code"] = this.code;
        data["responseCode"] = this.responseCode;
        return data; 
    }

    clone(): OverrideDetail {
        const json = this.toJSON();
        let result = new OverrideDetail();
        result.init(json);
        return result;
    }
}

export interface IOverrideDetail {
    id: string | undefined;
    description: string | undefined;
    code: string | undefined;
    responseCode: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}